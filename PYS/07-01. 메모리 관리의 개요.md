# 01 메모리 관리의 개요
- 이 장에서 살펴볼 메모리는 메인메모리를 가리킴

## 1 메모리 관리의 복잡성
- 메모리는 1B 크기로 나뉘고, 1B로 나뉜 각 영역은 메모리 주소로 구분하는데 보통 0번지부터 시작함
- CPU는 메모리 주소 레지스터(MAR)에 필요한 메모리 주소를 넣어 데이터를 메모리에서 가져오거나 메모리에 데이터를 옮길 수 있음
- 폰노이만 구조의 컴퓨터에서 메모리는 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행 가능함
- 오늘날의 시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 복잡함
    - 메모리는 빠르지만 비싸기 때문에 메모리를 계층적 구조로 만들어 작업 속도를 올리고 가격을 낮추는 계층적 메모리 구조(캐시 - 메모리 - 제2저장장치)를 사용함
    - 메모리 관리의 복잡성은 충분히 크지 않은 메모리에서 여러 작업을 동시에 실행하는 문제에서 비롯됨
- 복잡한 메모리 관리는 메모리 관리 시스템(Memory Management System, MMS)이 담당함

## 2 메모리 관리의 이중성
- 메모리 관리의 이중성이란 프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것을 말함
- 현대의 메모리 관리 시스템은 프로세스와 메모리 관리자의 상충되는 요구 사항을 완벽하게 처리함

## 3 소스코드의 번역과 실행
### 3.1 컴파일러와 인터프리터의 동작
- 저급 언어: 컴퓨터의 동작을 가장 직접적으로 표현한 언어 (기계어, 어셈블리어)
- 고급 언어: 사용자가 이해하기 쉽게 프로그래밍 할 수 있는 언어 (C 언어, 자바)
- 언어 번역 프로그램은 고급 언어로 작성한 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역하는 프로그램
    - 컴파일러: 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행함 (C 언어, 자바 등)
    - 인터프리터: 소스크드를 한 행씩 번역하여 실행 (자바스크립트, 베이직 등)

### 3.2 컴파일러의 목적
- 오류 발견
    - 컴파일러는 오류를 찾기 위해 심벌 테이블(symbol table)을 사용함
    - 심벌 테이블(symbol table): 변수 선언부에 명시한 각 변수의 이름과 종류(type)를 모아놓은 테이블로, 선언하지 않은 변수를 사용하지는 않았는지, 변수에 다른 종류의 데이터를 저장하지는 않았는지 알 수 있음
- 코드 최적화
    - 소스코드에서 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져서 실행 속도가 빨라짐
    - 컴파일러는 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일을 만듦

### 3.3 컴파일러와 인터프리터의 차이
- 컴파일러
    - 사용할 변수를 먼저 선언한 후 코드를 작성하는데, 오류를 찾고 코드를 최적화하기 위해 반드시 필요한 작업임
    - 실행 전에 소스코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만듦
    - 크고 복잡한 프로그램에 사용
- 인터프리터
    - 한 줄씩 위에서부터 아래로 실행되기 떄문에 같은 일을 반복하는 경우나 필요 없는 변수를 확인할 수 없음
    - 간단한 프로그램에 사용

### 3.4 컴파일 과정
- 컴파일: 사용자가 작성한 소스코드를 목적 코드(object code)로 변환한 후 라이브러리를 연결하고 최종 실행 파일을 만들어 실행하는 과정
1. 소스코드 작성 및 컴파일
    - 사용자가 작성한 소스코드를 컴파일러를 사용하여 번역하면 컴퓨터가 인식할 수 있는 0과 1의 기계어로 된 목적 코드를 얻을 수 있음
2. 목적 코드와 라이브러리 연결
    - 목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만듦
    - 라이브러리: 자주 사용하는 함수를 시스템 내에 미리 만들어둔 것, 프로그래머가 직접 만들기 어렵거나 만드는 데 시간이 많이 걸리는 함수를 파일 형태로 모아놓은 것
3. 동적 라이브러리를 포함하여 최종 실행
    - 동적 라이브러리: 실행할 떄 삽입되는 함수를 가진 라이브러리
    - 동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요 없이 새로운 라이브러리를 사용하여 실행하면 됨
    - 윈도우에서는 동적 라이브러리 파일을 DLL(Dynamic Link Loader)이라고 부름

## 4 메모리 관리자의 역할
- 메모리 관리는 메모리 관리자가 담당
- 메모리 관리자는 정확히 말해 메모리 관리 유닛(Memory Manage Unit, MMU)이라는 하드웨어인데, 일반적으로 메모리 관리자라고 일컬음
- 메모리 관리자의 작업
    - 가져오기 작업
        - 프로세스와 데이터를 메모리로 가져오는 작업
        - 메모리 관리자는 사용자가 요청하면 프로세스와 데이터를 모두 메모리 관리자로 가져옴
        - 메모리가 충분하지 않다면 데이터의 일부만 가져와 실행하기도 하고, 사용자의 요청이 없더라도 앞으로 필요할 것으로 예상되는 데이터를 미리 가져오기도 함   
    - 배치 작업
        - 배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요
            - 같은 크기로 자르느냐, 실행되는 프로세스의 크기에 맞게 자르느냐에 따라 메모리 관리의 복잡성이 달라지기 때문
        - 나누어진 메모리의 구역에 따라 가져온 프로세스와 데이터를 어떤 위치에 놓을지 결정하는 것
    - 재배치 작업
        - 꽉 차 있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업
- 메모리 관리자는 가져오기, 배치, 재배치 작업 시 아래의 정책을 수립하여 정책에 따라 메모리를 관리함
    - 가져오기 정책
        - 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책
        - 프로세스가 요청할 때 메모리로 가져오는 것이 일반적이나, 필요하다고 예상되는 데이터를 미리 가져오는 방법(prefetch)도 있음
    - 배치 정책
        - 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책
        - 페이징(paging): 메모리를 같은 크기로 자르는 것
        - 세그먼테이션(segmentation): 메모리를 프로세스의 크기에 맞게 자르는 것
        - 배치 정책은 페이징과 세그먼테이션의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만드는 것
        - 이는 한정된 자원을 효율저그로 사용하기 위한 것으로, 시스템의 효율을 좌우하는 매우 중요한 기준
    - 재배치 정책
        - 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책
        - 교체 알고리즘(replacement algorithm): 앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘, 시스템의 성능이 올라감
