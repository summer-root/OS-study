# 03 임계구역 해결 방법
- 임계구역 문제를 해결하는 단순한 방법은 __잠금(lock)__ 을 이용하는 것

## 2 임계구역 해결 조건을 고려한 코드 설계
### 2.1 상호 배제 문제
- 공유 변수 lock의 초깃값은 false(잠금이 해제되었다는 의미)
- 프로세스 P1은 1. while(lock == true); 문을 실행하고 나서 곧바로 3. lock=true; 문을 실행해야 다른 프로세스가 임계구역에 들어오는 것을 막을 수 있음

### 2.2 한정 대기 문제
- 교착 상태 (deadlock)
    - 프로세스가 살아 있으나 작업이 진행되지 못하는 상태
    - 한정 대기 조건을 보장하지 못하는 상황

### 2.3 진행의 융통성 문제
- lock 값이 1이면 프로세스 P1이 임계구역을 사용하고, lock 값이 2이면 프로세스 P2가 임계구역을 사용한다는 뜻
    - 2.1에서의 lock은 어떤 프로세스인지에 상관 없이 잠금이 걸려 있는지 걸려 있지 않은지를 나타냈지만, 2.3에서의 lock은 어떤 프로세스가 임계구역을 사용 중이고 잠금을 걸었는지를 나타냄
- 경직된 동기화 (lockstep synchronization)
    - 프로세스의 진행이 다른 프로세스로 인해 방햅다는 현상

## 5 세마포어
1. 세마포어는 사용 전에 초기 설정 [Semaphore(n)] 으로, 공유 가능한 자원의 수를 나타냄
2. 초기화가 끝난 후 임계구역에 들어가기 전에 사용 중이라고 표시 [P()]
3. 임계구역을 나올 때 비었다고 표시 [V()]
- 세마포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 wake_up 신호를 받으면 큐에서 나와 임계구역으로 진입
    바쁜 대기를 하는 프로세스가 없음
- 상호 배제와 한정 대기 조건을 보장하기 위해 세마포어의 P(), V() 내부 코드는 검사와 지정(test-and-set)을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 함

## 6 모니터
- 세마포어의 가장 큰 문제는 잘못된 사용으로 인해 임계구역이 보호받지 못 한다는 것
- 모니터
    - 공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따라 P(), V()를 사용할 필요 없이 자동으로 처리하도록 구현한 것
    - 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간 동기화를 시킴
    - 시스템 호출과 같은 개념
    - 모니터는 임계구역 보호와 동기화를 위해 내부적으로 상태 변수를 사용
        - wait() = P()
        - signal() = V()