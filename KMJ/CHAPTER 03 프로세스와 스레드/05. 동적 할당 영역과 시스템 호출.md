# 동적 할당 영역과 시스템 호출
## 프로세스의 동적 할당 영역
프로세스의 데이터 영역에는 힙 영역이 포함되어있다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUNyMq%2FbtrHOAE84MU%2FXkppgtDI9rBVbvLwjtw5A0%2Fimg.png)<br>

### 스택 영역
호출한 함수가 종료되면 함수를 호출하기 전 코드로 되돌아와야 하는데 되돌아올 메모리의 주소를 스택에 저장한다.<br>
<br>
스택은 변수 사용 범위에 영향을 미치는 영역scope를 구현할때 사용한다. 변수는 전역변수 global variable와 지역 변수local variable로 나뉘며, 전역 변수는 프로그램 내에 있는 모든 함수에서 사용 할 수 있고 지역변수는 특정 함수에서만 사용 할 수 있다. 함수에서 사용하는 지역변수는 함수가 호출될 때만 사용되다가 함수가 종료되면 사용한 공간을 반환해야 하는데 지역변수를 저장할때 스택이 사용된다. <br>
<br>
스택은 가장 먼저 들어간 데이터가 가장 나중에 나오는 자료구조로, 스택에 데이터를 삽입하는것을 push, 스택에서 데이터를 꺼내는것을 pop이라고 한다.<br>
<br>
스택은 프로세스를 작동하기 위해 커널이 유지하는 자료구조로, 스레드가 작동하는 동안 추가되거나 삭제되는 동적 할당 영역이다.<br>
<br>
프로그램을 조금이라도 빨리 작동하려면 모든 코드를 main()함수에 집어넣고 함수 호출을 최소화하면 스택을 유지하는 비용이 절약되어 프로그램의 속도가 빨라지지만 모든 코드를 하나로 묶기때문에 오류를 찾기 어렵고, 미리 만들어놓은 코드를 재사용하기 어려우며, 여러 사람이 나누어 작업하기도 어렵다. 따라서 함수를 사용한다.<br>

### 힙 영역
동적으로 할당되는 변수 영역이다. 대부분의 데이터는 데이터 영역에 할당되고 그 크기가 정해진다. 그러나 일부 데이터는 프로그램이 실행되는 동안 할당되는데 대표적인 경우가 malloc()함수이다.<br>
```c
main() {
    int sarr[50];
    int *darr;
 
    darr=(int*)malloc(sizeof(int)*50);
 
    free(darr);
```
<br>2행을 보면 sarr은 50개짜리 정수 배열int array이고, darr은 포인터로써 그 크기가 정해지지 않았다.<br>

이 프로그램을 실행하면 sarr은 데이터 영역에 50개짜리 정수 배열이 자리를차지하지만, darr은 빈 상태로 실행되다가 malloc을 만나면 그때야 메모리에 자리를 차지한다. 따라서 스레드가 darr=(int*)malloc(sizeof(int)*50) 문장을 만나면 힙 영역에 정수 50개의 공간을 배정해준다. 따라서 sarr은 데이터 영역에, darr은 힙영역에 50개의 정수배열을 만든다.<br>
<br>
sarr과 darr은 같은 크기이므로 어떤 것을 사용하건 큰 차이가 없을것같지만 실제로는 차이가 크다. <br>
- sarr : 사용여부에 상관없이 프로세스가 종료될때까지 메모리를 차지해 메모리를 낭비한다.
- darr : 필요할때 메모리를 차지햇다가 필요없어지면 메모리를 반환한다. 위 코드에서 free(darr)이 사용하던 메모리 공간을 반화하는 부분이다.

새로운 프로세스가 생성되면 malloc() 함수를 사용하여 프로세스 제어 블록의 구조체를 만들고 해당 큐에 삽입하면, 프로세스가 종료되면 free() 함수를 사용하여 해당 프로세스 제어 블록이 차지하던 메모리 공간을 반환한다.<br>

------------
## exit()와 wait() 시스템 호출
### exit() 시스템 호출
```c
main() {
    printf("Hello \n");
    exit(0);
}
```
모든 프로세스는 사용하던 지원을 용이하게 회수하기위해 부모-자식 관계를 가진다.<br>
<br>
exit()함수를  선언함으로써 부모 프로세스는 자식 프로세스가 사용하던 자원을 빨리 거둬갈 수 있다. 또한, 전달하는 인자를 확인해 자식 프로세스가 어떤 상태로 종료되었는지를 알 수 있는데, 인자가 0이면 정상종료이고, -1이면 비정상 종료이다. main() 함수의 맨 마지막 줄에 exit() 혹은 return()문을 사용하는것은 자식프로세스가 끝났음을 부모 프로세스에 알려주기 위함이다. <br>
<br>
두 프로세스가 독립적으로 움직이기때문에 둘 중 먼저 실행 상태에 들어간 프로세스의 결과가 먼저 출력된다.<br>

### wait() 시스템 호출
운영체제는 부모 프로세스가 먼저 종료됨으로써 고아 프로세스가 생기는것을 방지하기위해 wait() 시스템 호출을 사용한다. wait() 시스템 호출은 자식 프로세스가 끝나기를 기다렸다가 자식 프로세스가 종료되면 현재 프로세스의 구분자를 확인하기 위해 getpid()를 사용한다.<br>

만약 부모 프로세스의 프로세스 구분자를 알고싶다면 getpid()를 사용하면 된다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FH6DKw%2FbtrH0udXtip%2FLQo4vu0W9u2YpU77ZhqzNk%2Fimg.png)<br>
위 코드에서는 wait()함수가 추가되었으므로 자식 프로세스의 프로세스 구분자가 먼저 출력되고 부모 프로세스는 wait() 함수에서 자식 프로세스가 끝나기를 기다린다. 그러므로 위 코드는 부모 프로세스가 자식 프로세스보다 먼저 끝나는 경우가 없고 이러한 특징때문에 wait() 함수는 부모 프로세스와 자식 프로세스간 동기화에도 사용된다.<br>

- 전면 프로세스(foreground process) : 앞에서 작동하는 프로세스를 말한다. 작업이 끝날 때까지 셀이 다음 명령어의 입력을 받아들이지 않는다. 셀이 wait() 함수를 사용한다.
- 후면 프로세스(background process) : 뒤에서 작동하는 프로세스를 말한다. 프로세스를 실행한 후 바로 다음 명령어를 실행할 준비를 한다. 셀이 wait() 함수를 사용하지 않는다. 
