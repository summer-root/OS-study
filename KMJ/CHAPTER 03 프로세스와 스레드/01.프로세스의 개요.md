# 프로세스의 개요
## 프로세스의 개념
### 프로세스
하나의 작업 단위<br>
실행을 위해 메모리에 올라온 동적인 상태<br>
작성된 작업 절차를 실제로 실행에 옮긴다.<br>

### 프로그램
하드디스크와 같은 저장장치에 저장되어있는 정적인 상태<br>
어떤 작업을 할지 그 절차를 적어놓은 것<br>

### 요리사 모형에의 비유
#### 일괄 작업 시스템
한 번에 하나의 작업만 처리<br>
제공되는 순서가 단순하고, 작업하는 동안 쉬는 시간이 생기며, 하나의 작업이 끝나야 다른 작업을 할 수 있어 작업효율이 떨어진다.<br>
큐로 처리되어 먼저 들어온 작업이 먼저 처리된다.<br>

###### * 큐 queue
주문 목록
먼저 들어온 데이터가 먼저 빠져나가는 구조<br>

###### * 스택
먼저 들어온 데이터가 마지막에 빠져나가는 구조<br>

### 시분할 방식
CPU가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 동시에 실행하는 것처럼 느껴지고 효율적이다.<br>
실행하던 작업이 오래 걸릴 경우 다른 작업을 대기목록으로 옮김으로써 다른 작업을 할 수 있기 때문에 작업의 효율성이 높아진다.<br>
언제 다시 시작될지 모르거나 중간에 그만둘지 모르는 작업은 보류 목록으로 옮긴다. <br>

------------


## 프로그램에서 프로세스로의 전환
프로세스는 컴퓨터 시스템의 작업 단위로 태스크 task라고도 부른다.<br>
시분할 방식 시스템에서 프로그램이 프로세스로 전환될 때 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.<br>
그와 동시에 작업지시서인 **프로세스 제어 블록(Process Control Block; PCB)**을 만든다.
프로세스 제어 블록에는 프로세스를 처리하는데 필요한 다양한 정보가 들어있고, 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못한다.<br>
어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록을 받았다는 의미이다.<br>

### 프로세스 구분자 (Process IDentification; PID)
메모리에는 여러 개의 프로세스가 존재하므로 각 프로세스를 구분하는 프로세스 구분자가 필요하다.<br>

### 메모리 관련 정보
CPU는 실행하려는 프로세스가 메모리의 어디에 저장되어있는지를 알아야 작업을 할 수 있기 때문에 프로세스 제어블록에는 프로세스의 메모리 위치 정보가 담겨있다.<br> 또한 메모리 보호를 위한 경계 레지스터와 한계 레지스터도 포함되어있다. <br>

### 각종 중간값
프로세스 제어 블록에는 프로세스가 사용했던 중간값이 저장되는데, 시분할 시스템에서는 여러 프로세스가 번갈아가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPU를 넘겨준다.<br>
<br>
프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다.<br>
또한 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.<br>
 
###### * 프로세스와 프로그램의 관계
프로세스 = 프로그램 + 프로세스 제어 블록<br>
프로그램 = 프로세스 + 프로세스 제어 블록<br>
운영체제도 프로그램이 기 때문에 프로세스 형태로 실행되어야 한다.<br>

대표적으로 부트스트랩이 있는데, 부트스트랩이 많은 운영체제 관련 프로세스를 실행한 후 일반 프로세스가 실행되므로 컴퓨터에는 일반 사용자의 사용자 프로세스 user process와 운영체제의 커널 프로세스 kernel process가 섞여서 실행된다.<br>

------------


## 프로세스의 상태
운영체제에서도 여러 가지 이유로 프로세스 상태가 변화된다.

-** 일괄 시스템의 경우** : 프로세스가 생성된 후 CPU를 얻어 실행되고 작업을 마치면 종료된다. 일괄 작업 시스템의 프로세스 상태는 생성 create, 실행 run, 완료 terminate이다.
- **시분할 시스템의 경우** : CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하기 때문에 일괄 시스템보다 복잡하다. 운영체제에서도 이제 막 프로세스가 되었거나 CPU를 사용하다가 쫓겨난 프로세스는 준비 상태에서 자기 순서를 기다린다.

### 프로세스의 네 가지 상태
- **생성 상태 create status** : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태이다. 프로세스를 관리하는데 필요한 프로세스 제어 블록이 생성된다.
- **준비 상태 ready status** : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태이다. CPU가 하나인 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 자기 실행 순서가 될 때까지 준비 상태에서 기다려야 한다.
- **실행 상태 running status** : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태로 'execute status'라고 표현하기도 한다. 실행 상태에 들어간 프로세스는 일정 시간 동안 CPU를 사용할 권리를 가진다. 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면 프로세스는 준비 상태로 돌아와 다음 차례를 기다린다. 프로세스는 자신의 작업이 끝날 때까지 준비상태와 실행상태를 왔다 갔다 한다.
- **완료 상태 terminate status **: 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다. 완료 상태는 프로세스 제어 블록이 사라진 상태를 의미한다.

####  CPU 스케줄러(CPU schedular)
준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일을 담당한다.<br>  준비 상태의 맨 앞에서 기다리고 있는 프로세스 제어 블록을 CPU에 전달하여 작업이 이루어지게 한다.<br>
준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 스케줄러의 작업을 디스패치 dispatch라고 한다.<br>
CPU 스케줄러는 프로세스의 전 상태, 즉 생성, 준비, 실행, 완료에 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 관리한다.<br>

#### 타임 슬라이스 or 타임 퀸텀
CPU 스케줄러에 의해 선택된 프로세스는 실행 상태에서 일정 시간 동안 작업을 하는데, 프로세스에 배당된 작업 시간을 말한다.<br>

#### 타임아웃 time out
프로세스는 자신에게 주어진 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아가는 것을 말한다.<br>
<br>
새로운 프로세스가 실행 상태로 들어오면 CPU는 일정 시간(타임 슬라이스)이 흐른 뒤 알려달라고 클록에 요청한다. 일정 시간이 다 되면 클록은 인터럽트를 사용해 일정 시간이 흘렀다고 CPU에 알려준다.<br>

### 프로세스의 다섯가지 상태
프로세스는 생성, 준비, 실행, 완료의 네 가지 상태만으로 작업을 진행하는데 큰 문제가 없으나 오늘날 운영체제의 효율성을 고려해 대기상태를 더 만들었다.<br>

#### 대기상태 blocking status
실행상태에 있느 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태로 'Wait status'라고도 한다.<br>
작업의 효율을 위해 만들어진것으로, 대기 상태의 프로세스는 입출력 장치별로 마련된 큐에서 기다린다.<br>
입출력이 완료되면 인터럽트가 발생하고, 대기상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데 이를 wake up이라고 한다. <br>
<br>
대기 상태의 프로세스는 원래 실행 상태에서 옮겨 왔기 때문에 입출력이 끝나면 실행상태로 돌아가는 것이 맞지만, 그러려면 현재 실행 상태에서 작업 중인 프로세스를 준비상태로 돌려보내야 한다. <br>
두 프로세스의 상태를 변화시켜야 하는 복잡한 상황이므로, 대기 상태에서 입출력이 끝난 프로세스는  실행 상태로 가지 않고 준비 상태로 돌아가 자기 차례를 기다린다. <br>

### 휴식 상태와 보류 상태
대부분의 프로세스는 생성, 준비, 실행, 대기, 완료 상태로 운영되며 이 다섯 가지 상태를 활성 상태 active status라고 한다. 프로세스의 상태는 활성 상태 외에 다른 상태가 있는데, 다음은 조금 특별한 경우이다.<br>

- 휴식 상태 pause status : 프로세스가 작업을 일시적으로 쉬고 있는 상태이다. (정지; stop).  
- 보류 상태 suspend status : 프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다. 일시 정지 상태라고도 불리며 다음과 같은 경우에 보류 상태가 된다.
 - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼때
 - 프로그램에 오류가 있어서 실행을 미루어야 할 때
 - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
 - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
 - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때 

보류 상태에 들어가 프로세스는 메모리 밖으로 쫓겨나 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳인 스왑 영역 swap area에 보관된다. <br>
보류 상태는 대기에서 옮겨진 보류 대기 상태 block suspend status와 준비상태에서 옮겨진 보류 준비 상태 ready suspend status로 구분되며, 각 상태에서 재시작하면 원래의 활성 상태로 들어간다. <br>
또한, 보류 대기 상태에서 입출력이 완료되면 활성 상태가 아닌 보류 준비 상태로 옮겨간다.<br>
