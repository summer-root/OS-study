
#  파일과 파일 시스템

#  파일 시스템의 개요

##  파일 시스템의 개념

###  파일 시스템

- 사용자가 파일을 직접 보관하거나 접근하는 대신 파일을 보관하고 관리하는 파일 관리자를 두어 저장장치의 전체 관리를 맡기는것.
- 파일 시스템에서 파일 관리자는 사용자의 요청에 따라 파일을 저장하거나 파일의 내용을 읽어온다.
- 저장장치에서는 파일관리자가 파일 테이블을 사용해 파일을 관리한다.
	- 파일 테이블을 사용해 파일의 생성, 수정, 삭제 등을 수행하고 사용자가 파일을 사용하고자 할 때 읽기, 쓰기, 실행과 같은 다양한 접근 방법을 제공한다.
- 사용자가 특정 파일에 접근하려면 파일 관리자로부터 파일에 접근할 수 있는 권한(키)를 획득해야 하는데, 이러한 파일 접근 권한을 파일 디스크립터(file descriptor)라고 한다.

###  파일 시스템의 기능

파일 테이블의 구성은 운영체제마다 다른데 공통적으로 다음과 같은 기능을 유지한다.

|기능|설명  |
|--|--|
| 파일 구성 | 사용자의 요구에 따라 파일과 디렉터리를 만든다. |
| 파일 관리 | 파일 생성, 수정, 삭제 등의 관리를 하고 수시로 조각모음을 해 사용자가 파일에 빨리 접근할 수 있도록 한다. |
| 접근 권한 관리 | 다른 사용자로부터 파일을 보호하기 위해 접근 권한을 관리한다. |
| 접근 방법 제공 | 파일을 읽고 쓰고 실행할 수 있도록 사용자에게 접근 방법을 제공한다. |
| 무결성 보장 | 파일의 내용이 손상되지 않도록 무결성을 보장한다. |
| 백업과 복구 | 사고로부터 파일을 보호하기 위해 백업과 복구 작업을 한다. |
| 암호화 | 파일을 암호화해 악의적인 접근으로부터 파일을 보호한다. |


파일 시스템은 파일을 생성하고, 사용자가 파일을 편리하게 관리할 수 있도록 디렉터리 구조를 제공한다.<br>
여러 종류의 파일을 구분하기 위해 파일이름과 확장자를 만들어 관리하고, 다양한 파일 정보는 파일 헤더에 저장해 관리한다.<br>

### 블록과 파일 테이블
데이터는 운영체제와 저장장치 간에 블록 단위로 전송된다.

### 블록 
저장장치에서 사용하는 가장 작은 단위. 한 블록에 주소 하나가 할당된다.<br>
<br>
메모리는 바이트 단위로 저장되고, 하드디스크의 물리적인 구조상 가장 작은 저장단위는 섹터이다.<br>
메인 메모리는 보통 수 기가바이트이지만 하드디스크는 수 테라바이트이므로 메모리보다 수백 배 이상 크다.<br>
→ **섹터마다 주소를 부여하면 너무 많은 양의 주소가 필요하기때문에 파일 관리자는 여러 섹터를 묶어 블록으로 만들고, 블록 하나에 주소 하나를 배정한다.**<br>
<br>
블록의 크기는 시스템마다 다르기때문에 사용자는 포맷을 할 때 시스템이 정한 기본 블록 크기를 사용할 수도 있고, 4,096B~64KB의 다양한 블록 크기를 직접 지정할 수도 있다.<br>

![enter image description here](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bGM0Cf/btrPT2fB1qQ/DPqo57NI8bsSc2aPg8pCM0/img.jpg)
   포맷을 하면 각 블록에 번호가 매겨지고 파일 테이블에는 파일이 어떤 블록에 있는지 명시된다.<br>
   위 그림에서 사용자가 파일 A를 요청하면 1번, 3번, 9번 블록을 읽어서 사용자에게 돌려준다.<br>

이때 블록 크기를 작게 설정하면 내부단편화 현상이 줄어들어 저장장치를 효율적으로 쓸 수 있지만, 파일이 여러 블록으로 나뉘어 파일 입출력 속도가 느려진다.<br>
따라서 큰 파일을 많이 사용할 때는 블록 크기를 크게 잡는것이 좋다.<br>


# 파일 분류와 확장자

파일은 논리적인 데이터의 집합으로 하드디스크나 CD같은 제 2저장장치에 저장된다.<br>
모든 파일은 0과 1의 비트 패턴(bit pattern)으로 이루어지며, 운영체제 입장에서는 크게 실행 파일과 데이터 파일로 나뉜다.<br>
<br>
- 실행 파일 :  운영체제가 메모리로 가져와 CPU를 이용해 작업을 하는 파일이다. 즉, 사용자의 요청으로 프로세스가 된 파일을 말한다.
- 데이터 파일 : 실행파 일이 작업하는데 필요한 데이터를 모아놓은 파일이다. 데이터 파일은 스스로 프로세스가 될 수 없고 운영체제가 전송하거나 보관만 할 뿐 특별하게 다루지 않는다. 운영체제 입장에서 모든 데이터 파일은 0과 1로 이루어진 데이터의 덩어리다.
<br>
컴퓨터에는 다양한 종류의 데이터 파일이 존재하기때문에 이러한 다양한 종류의 파일을 구분하기위해 헤더가 달려있다.<br>
파일 헤더에는 파일의 이름, 버전, 크기, 만든 날짜, 접근 권한 등의 정보가 저장되며, 모든 종류의 파일은 각각 고유한 헤더를 가지고 있다.<br>
모든 파일 이름에는 확장자가 붙는데, 확장자를 통해 파일의 성격을 알 수 있다.<br>
<br>
다음 표는 현재 많이 사용되는 파일의 확장자를 정리한것으로, 실행 파일을 제외한 나머지는 모두 데이터 파일의 확장자이다. <br>
윈도우의 실행 파일은 exe나 com과 같이 확장자가 정해져있지만 유닉스는 정해진 확장자가 없다.<br>

| 파일 | 확장자 | 설명 |
|--|--|--|
| 실행 파일 | exe, com | 유닉스에서는 실행 파일 확장자가 없음 |
| 소스코드 파일 | c, cpp, pas, a, java | 다양한 소스코드의 확장자 |
| 라이브러리 파일 | lib, a, dll | 소스코드를 위한 라이브러리의 확장자 |
| 배치 파일 | bat, sh, csh | 초기 배치 파일의 확장자 |
| 문서 파일 | txt, doc, hwp, pdf, ps 등 | 문서 데이터 파일의 확장자 |
| 동영상 파일 | avi, asf, mkv, mov, rmv | 동영상 데이터 파일의 확장자 |
| 음악 파일 | wav, mp3, ogg, flc, aac | 음악 데이터 파일의 확장자 |
| 이미지 파일 | bmp, gif, jpg, tiff, png | 이미지 데이터 파일의 확장자 |
| 압축 파일 | rar, zip, arc, al | 압축 파일의 확장자 |


##### 확장자 표준과 신설
확장자는 mp3, bmp, jpg, zip 등과 같이 전세계적으로 표준을 정하여 사용한다. 하지만 응용 프로그램 제작자에 따라 새로 만들어 사용할 수 있다.<br>
한글의 확장자는 hwp, 마이크로소프트의 MS-Word의 확장자는 doc, 압축파일의 확장자는 rar, zip, 알집의 확장자는 al이다.<br>


## 파일 이름과 연결 프로그램

대부분의 파일 이름은  `파일이름.확장자`의 형태로 구성된다.<br>

### 파일 이름과 관련해 유의할 사항
- 초창기의 운영체제에서는 파일 이름이 8자, 확장자 이름이 3자로 제한되었는데, 그 영향으로 아직도 파일 확장자는 3자리 이하가 대부분이지만 4자나 5자로 된 확장자도 있다.
- 파일 이름에 마침표.를 여러 번 사용할 수 있는데, 이때는 마침표 다음 글자를 확장자로 인식한다.
	- `run.2017.10.avi`라면 마지막의 `avi`를 확장자로 인식한다.
- 파일 이름은 현재 경로 이름을 포함해 최대 255자로 할 수 있다. 
	- 파일 이름만이 아니라 경로 이름을 포함해서 255자이다. 
	- 경로는 파일이 있는 위치를 나타내는 정보이다.
- 파일 이름에는 영문자, 숫자, 붙임표(-), 밑줄(_), 마침표(.)를 주로 사용한다. 
	- 윈도우에서는 파일 이름에 스페이스바, &, ~ 등의 특수문자를 사용할 수 있고 \, /, :, *, ", <, >, | 등의 특수문자를 사용할 수 없다. 또한 대문자와 소문자를 구분하지 않는다.
	- 유닉스에서는 파일 이름에 스페이스바를 포함하여 대부분의 특수문자를 사용할 수 없다. 또한 대문자와 소문자를 구분한다.

윈도우에서 실행 파일을 더블클릭하면 프로세스가 생성되어 실행된다. <br>
반면 데이터 파일을 더블클릭하면 해당 파일을 사용하는 응용 프로그램이 실행되는데 이러한 프로그램을 연결 프로그램이라고 한다.<br>
실행 파일과 데이터 파일은 둘 다 더블클릭하면 실행되기때문에 데이터 파일을 실행 파일로 착각하기 쉽다. <br>
하지만 데이터 파일이 필요로 하는 응용 프로그램을 운영체제가 실행하는 것이지 데이터 파일 자체가 실행되는 것은 아니다.<br>
<br>
윈도우에서 데이터 파일에 연결된 응용 프로그램을 바꾸고 싶을 때는 연결 프로그램을 변경하면 된다. <br>
파일을 선택하여 마우스 왼쪽 버튼을 누르고 [속성] 메뉴를 클릭하면 변경할 수 있다.<br>
주의할 점은 확장자를 바꾼다고 해서 내용이 바뀌지 않는다는 것이다.<br>

## 파일 속성

대부분의 파일은 다음과 같은 속성이 있다.<br>

| 속성 | 특징 |
|--|--|
| name | 파일의 이름 |
| type | 파일의 종류 |
| size | 파일의 크기 |
| time | 파일의 접근 시간 |
| location | 파일의 위치 |
| accesibility | 파일의 접근 권한 |
| owner | 파일의 소유자 |

- name, type 
	- 파일의 이름은 확장자를 포함한 전체 이름을 의미한다. 
	- 파일의 종류는 실행 파일, 동영상 파일, 사진 파일, 음악 파일과 같이 확장자로 구분된다.
- size, time 
	- 파일의 크기는 파일의 용량을 의미한다. 
	- 파일의 접근 시간은 만든 시간, 변경 시간, 최근 파일을 열어본 시간 등으로 세분된다.
- location 
	- 이름과 확장자가 같은 두 파일은 한 디렉터리에 존재할 수 없으며 서로 다른 디렉터리에 각각 존재할 수 있다. 
	- 파일의 위치가 다르면 운영체제는 서로 다른 파일이라고 여긴다.
- accessibility, owner 
	- 윈도우에서는 파일의 소유자라는 개념이 거의 없지만, 유닉스에서는 명확하게 구분하여 사용된다. 
	- 파일의 접근 권한도 윈도우에서는 읽기, 쓰기, 숨김 파일 정도로만 구분하지만 유닉스에서는 소유자, 그룹, 제삼자에 따라 다르게 설정할 수 있다.

운영체제가 관리하는 파일 헤더 외에 데이터 파일마다 자신에게 필요한 파일 속성을 따로 정의하여 사용하기도 하는데, 이는 파일의 고유 헤더에 기록된다.
![enter image description here](https://velog.velcdn.com/images/tnwls2/post/678788c8-1aa9-4b46-a7ce-e0d0de639432/image.png)
- 파일 헤더 
	- 파일 테이블에서 관리하며 파일의 이름, 종류, 크기, 시간, 접근 권한 등과 같은 일반적인 내용이 담겨있다.
	- 파일이 저장장치의 몇 번째 블록에 있는지에 대한 정보도 가지고있다.
- 고유 헤더 
	- 데이터 파일에는 응용 프로그램이 필요로 하는 고유 헤더가 따로 달려있다. 
	- 고유 헤더에는 파일의 버전 번호, 크기, 특수 정보 등 응용 프로그램이 필요로 하는 정보가 담겨있다.
	- 고유 헤더는 파일을 복구할 때 유용하게 사용된다.
		- 빠른 포맷을 했을 경우 파일 테이블에 있던 파일 헤더가 사라질 것이다. 하지만 빠른 포맷은 파일 테이블만 지운것이지 실제 데이터를 지우지 않는다. 따라서 데이터 파일이 고유 헤더는 저장장치에 남아있으며 파일 복구 시스템은 모든 블록을 찾아다니면서 고유 헤더에 있는 정보를 이용하여 파일을 원래 상태로 복원한다.

## 파일 작업의 유형
### 파일 작업
- 파일을 지우거나 이름을 바꾸는것과 같이 파일을 변경하는 것을 말한다.
- 파일 연산(file operation)이라고 한다.

#### 파일 자체를 변경하는 작업

| 작업 | 설명 | 작업 | 설명 |
|--|--|--|--|
| open | 파일을 연다. | copy | 파일을 복사한다. |
| close | 파일을 닫는다. | rename | 파일의 이름을 변경한다. |
| create | 새로운 파일을 생성한다. | list | 파일을 나열한다. |
| remove | 파일을 이동한다. | search | 파일을 찾는다. |
- open, close
	- 파일을 더블클릭하면 연결 프로그램이 실행되어 파일이 열린다. 또는 연결 프로그램을 실행한 후 데이터 파일을 가져온다. 파일을 다 사용하고 나면 닫는다.
	- 응용 프로그램을 종료해도 자동으로 파일이 닫힌다.
- create
	- 파일 생성은 새로운 파일을 만드는것이다.
- remove, copy, rename
	- 파일 이동 : 저장된 디렉터리의 위치를 변경하는 것. 파일을 다른 디렉터리로 이동하거나 휴지통으로 이동하면 파일이 삭제된다.
	- 파일 복사 : 똑같은 파일을 하나 더 만드는것
	- 파일 이름 변경 : 파일 이름을 바꾸는 것
- list
	- 파일 나열은 디렉터리에 있는 파일의 이름을 보여주는 것으로, 파일의 이름뿐 아니라 크기, 만든 날짜 등도 같이 나열된다.
- search
	- 여러 디렉터리에서 파일을 찾을 때는 검색을 사용한다. 이름순, 크기순, 만든 날짜 순 등 다양한 기준으로 검색이 가능하며, 다음과 같은 특수 기호를 사용하여 검색할 수도 있다.
		- "*" : 모든 문자를 대체한다.
		- ? : 검색 결과가 너무 많을 경우 물음표(?)를 사용해 검색 결과를 줄일수 있다. ab?로 검색했을 경우 ab로 시작하되 한 글자가 더 있는 파일을 찾으라는 의미로 aba, abb, abc와 같은 파일이 검색 결과에 나타난다.

#### 파일 내용을 변경하는 작업
파일 내용을 변경하는 작업은 프로세스 입장에서 수행하는 것으로 주로 함수 형태이다.<br>

| 작업 | 설명 | 작업 | 설명 |
|--|--|--|--|
| open() | 파일을 연다. | write() | 파일에 새로운 내용을 쓴다. |
| create() | 새로운 파일을 생성한다. | update() | 파일 내용 중 일부를 변경한다. |
| close() | 파일을 닫는다. | insert() | 파일에 새로운 내용을 추가한다. |
| read() | 파일 내용을 읽는다. | delete() | 파일 내용 중 일부를 지운다. |

- open(), create() : 운영체제로부터 이용 권한을 획득
- close() : 작업 종료시 파일의 작업이 끝났다는것을 운영체제에 알림
- 파일 이동 : 디스크립터
-  update(), insert(), delete() 연산은 read()또는 write()로도 구현할 수 있다.


## 파일 구조
파일은 하나의 데이터 덩어리이다. <br>
파일 구조는 이  데이터 덩어리를 어떻게 구성하느냐에 따라 순차 파일 구조, 인덱스 파일 구조, 직접 파일 구조로 나눌 수 있다.<br>

### 순차 파일 구조 
기본적인 일반 파일의 구조.<br>
파일의 내용이 하나의 긴 줄로 늘어선 형태인 카세트테이프가 대표적인 예이다.<br>
원하는 음악을 듣기 위해서는 테이프를 앞으로 감거나forward 뒤로 감아서backward 원하는 위치로 가야 한다. (`순차 접근 sequential access`)<br>
플로피 디스크나 하드디스크 같은 원반형 저장장치는 테이프 저장장치가 개발되고 나서 한참 후에 보급되었기때문에, 초기의 컴퓨터는 카세트테이프를 저장장치로 사용해 순차 파일 구조로 저장되었다.<br>

![enter image description here](https://velog.velcdn.com/images/tnwls2/post/f9793b8d-1098-4ed0-9d07-700707a4937d/image.png)<br>
open() 또는 create() 명령을 사용해 운영체제로부터 이용권한을 얻고, 운영체제는 파일 이용 허가를 내리면서 파일 디스크립터를 사용자에게 준다. <br>
이때 파일 디스크립터는 파일의 맨 앞에 위치한다.<br>
순차 파일 구조는 카세트 테이프와 마찬가지로 사용자가 read()나 write() 명령을 내리면 디스크립터가 계속 전진하며, 작업을 하다가 특정 위치로 디스크립터를 옮겨야 할 때는 lseek() 명령을 사용한다.<br>

#### 순차 파일 구조의 장점
- 모든 데이터가 순서대로 기록되기때문에 저장 공간에 낭비되는 부분이 없다.
- 구조가 단순해 테이프는 물론 플로피디스크나 메모리를 이용한 저장장치에도 적용할 수 있다.
- 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리된다.

#### 순차 파일 구조의 단점
- 파일에 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸린다. (데이터의 변경이 잦은 경우에 적당하지 않다.)
- 특정 데이터로 이동할 때 직접 접근이 어렵기때문에 앞에서부터 순서대로 움직여야 한다. (데이터 검색에 적당하지 않다.)

### 인덱스 파일 구조
순차 파일 구조의 단점을 해결한 파일 구조로, 순차 파일 구조에 인덱스 테이블을 추가해 순차 접근과 직접 접근이 가능하다.<br>
대표적인 예로는 CD를 들수있는데, 인덱스 파일이 모든 곡의 시작 부분을 가지고있기때문에 특정 곡에 직접 접근이 가능하다. (인덱스 순차 접근 `indexed sequential access`)<br>

![enter image description here](https://velog.velcdn.com/images/tnwls2/post/775d7260-c2eb-4c6c-b3d4-8de50f6026dc/image.png)
모든 데이터는 오른쪽과 같이 순차 파일 구조로 저장되어 있고, 각 순차 파일의 시작점에 블록 번호가 매겨져있다.<br>
왼쪽의 인덱스 테이블에는 블록번호와 함께 제목, 가수 등의 정보가 순서대로 정렬되어있다.<br>
만약 4번 노래가 듣고싶다고 명령을 내리면 인덱스 테이블에서 4번 곡의 블록 번호를 찾아 해당 블록으로 이동해 4번 곡을 재생한다.<br>
<br>
현대의 파일 시스템은 인덱스 파일 구조로, 파일을 저장할때는 순차 파일 구조로 저장하고 파일에 접근할 대는 인덱스 테이블을 보고 원하는 파일에 직접 접근한다.<br>

#### 인덱스 파일 구조의 장점
- 테이블을 여러 개 만들면 다양한 접근이 가능하다. (데이터베이스같이 데이터의 빠른 접근이 필요한 시스템에 사용된다.)
	- 데이터 베이스의 구축에는 다양한 알고리즘이 사용되며, 인덱스 구성 방법에 따라 데이터의 접근 속도가 달라지는데 일반적으로 B 트리를 이용해 인덱스를 구성한다.
	- 
##### B 트리
![enter image description here](https://velog.velcdn.com/images/emplam27/post/ddbae2c9-da94-457d-bad8-77ff6791255b/B%ED%8A%B8%EB%A6%AC%20%EA%B8%B0%EB%B3%B8%20%ED%98%95%ED%83%9C.png)
이진트리와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있다.<br>
 **최대  M개의 자식**을 가질 수 있는 B트리를 **M차 B트리**라고 한다.<br>
 위 그림은 차수가 3인 B트리 인데, 파란색 부분은 **각 노드의 key**를 나타내며, 빨간색 부분은 **자식 노드들을 가르키는 포인터**이다. key들은 노드 안에서 항상 정렬된 값을 가지며, 이진검색 트리처럼 각 key들의 왼쪽 자식들은 항상 key보다 작은 값을, 오른쪽은 큰 값을 가진다.<br>
https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree<br>

### 직접 파일 구조
저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조이다.<br>

![enter image description here](https://velog.velcdn.com/images/tnwls2/post/23d036d3-244d-4714-b254-f39306e0a6a9/image.png)<br>
키를 학번으로 해 대학생들의 정보를 저장하다고 가정했을때 학번을 10으로 나누어 나머지를 가지고 주소를 바꾼다.<br>
이 경우 끝자리가 0인 학생은 0번 저장장치에, 1인 학생은 1번 저장장치에 저장되게되고 데이터를 찾을때도 끝자리를 기준으로 찾는다.<br>
이런식으로 직접 파일 구조는 특정 함수를 사용해 직접 접근이 가능한 파일 구조이며, 이때 사용하는 함수를 해시 함수hash function이라고 한다.<br>

#### 직접 파일 구조의 장점
- 해시 함수를 이용해 주소를 변환하기 때문에 데이터 접근이 매우 빠르다.
#### 직접 파일 구조의 단점
- 직접 파일 구조를 제대로 작성하기위해 전체 데이터가 고르게 저장될 수 있는 해시 함수를 찾아야 한다.
- 모든 주소에 일정량의 데이터가 고르게 저장되지 않아 빈 공간이 생겨 저장장치의 이용 효율이 떨어진다.
