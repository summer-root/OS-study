# 메모리 관리의 개요
※ 이 장에서 살펴볼 메모리는 메인 메모리를 말한다.<br>

## 메모리 관리의 복잡성
메모리의 구조는 1B로 나뉜다.<br>
1B로 나뉜 각 영역은 메모리 주소로 구분하는데 보통 0번지부터 시작한다.<br>
CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용한다.<br>
메모리 주소 레지스터에 필요한 메모리 주소를 넣으면 데이터를 메모리에서 가져오거나 메모리에 데이터를 옮길 수 있다.<br>
<br>
폰 노이만 구조의 컴퓨터에서 메모리는 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행이 가능하다.<br>
과거의 일괄처리 시스템에서는 한 번에 한 가지 작업만 처리했기 때문에 메모리 관리가 어렵지 않았으나, 오늘날의 시분할 시스템에서는 운영체제를 포함한 모든 응용프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 복잡하다.<br>
<br>
운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.<br>
따라서 메모리에는 사용자 프로세스뿐 아니라 운영체제 프로세스도 공존한다.<br>
컴퓨터가 부팅(컴퓨터를 사용할 수 있는 환경을 마련하는 과정)을 할 때 하드디스크에 저장된 운영체제가 메모리에 올라간다. 부팅이 끝나면 여러 응용 프로그램이 메모리에서 작업을 할 수 있다.<br>
<br>
메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가에 관한 문제로 이러한 복잡한 메모리 관리는 메모리 관리 시스템(Memory Management System; MMS)이 담당한다.<br>

## 메모리 관리의 이중성
프로세스 입장에서는 메모리를 독차지하려하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것을 말한다.<br>
<br>
메모리 관리자 입장의 메모리 공간 관리는 매우 복잡하다. <br>
프로세스가 작업하는 도중에 할당된 공간이 부족할 경우 메모리 관리자는 새로운 공간을 확보하기 위해 옆의 프로세스를 밀어내거나 더 큰 공간으로 해당 프로세스를 옮긴다.<br>
작업을 마치고 난 후 빈공간이 생기면 다음 작업을 위해 빈 공간을 어떻게 처리할지도 결정한다.<br>
이때 빈 공간이 여러개 생길 경우 합쳐서 하나의 큰 공간을 만드는데, 이렇게 하기 위해 현재 작업 중인 공간을 옆으로 밀고 작은 공간을 합쳐나간다.<br>

##### 프로그램을 SSD와 같은 빠르고 큰 저장장치가 아닌 메모리에서 실행하는 이유는?
다른 주변장치보다 비싼 메모리 대신 느리고 값싼 하드디스크를 제2저장장치로 사용하고 비싸고 빠른 메모리는 작업 공간으로 사용한다.<br>
같은 맥락에서 메모리보다 용량은 작지만 CPU 속도로 작동하는 캐시메모리를 추가로 사용하여 전체 시스템의 작업 속도를 빠르게 한다.<br>
<br>
이렇게 메모리를 계층적 구조로 만들어 작업 속도를 올리고 가격을 낮추는 방법을 계층적 메모리 구조라고 한다.<br>

## 소스코드의 번역과 실행
### 컴파일러와 인터프리터의 동작
컴퓨터에서 작동하는 응용프로그램은 프로그래밍 언어로 만들며 보통은 컴파일러를 사용하여 작성한 프로그램을 실행 가능한 코드로 변경한다.<br>
<br>
처음부터 컴퓨터에서 실행 가능한 프로그램을 만들기 위해서는 0과 1로 이루어진 기계어로 만들면 된다.<br>
기계어와 어셈블리어는 컴퓨터의 동작을 가장 직접적으로 표현한 언어로 저급언어(low level language)라고도 하며 배우기 어렵고 이해하기도 어렵다.<br>
저급 언어와 반대되는 개념인 고급언어(high level language)는 사용자가 이해하기 쉽게 프로그래밍할 수 있는 언어로 C언어와 자바가 대표적이다.<br>

언어 번역 프로그램은 고급 언어로 작성한 소스코드를 컴퓨터가 실행 할 수 있는 기계어로 번역하는 프로그램이다.<br>
대표적으로는 컴파일러와 인터프리터가 있다.<br>
- 컴파일러 compiler : 소스코드를 컴퓨터가 실행할수있는 기계어로 번역한 후 한꺼번에 실행한다. C언어, 자바 등이 이 방식으로 프로그램을 실행한다. 컴파일러는 코드를 전체적으로 훑은 후 오류나 불필요한 오류가 있는지 살펴보고 오류가 발생하면 즉시 개발자에게 알려 수정할 수 있도록 한다.
- 인터프리터 interpreter : 소스코드를 한 행씩 번역하여 실행한다. 자바스크립트, 베이직 등이 이 방식으로 프로그램을 실행한다.

### 컴파일러의 목적
#### 오류 발견
소스코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것으로 컴파일러는 오류를 찾기 위해 심벌 테이블(symbol table)을 사용한다.<br> 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 종류(type)를 모아놓은 테이블로, 선언하지 않은 변수를 사용하지는 않았는지, 변수에 다른 종류의 데이터를 저장하지 않았는지 알 수 있다.<br>

#### 코드 최적화
소스코드에서 사용하지 않는 변수 등을 삭제하면 코드가 간결해져서 실행 속도가 빨라진다.<br> 결론적으로 컴파일러는 실행하지 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일을 만든다.<br>
<br>
윈도우 운영체제에서 컴파일된(실행 가능한) 프로그램의 확장자는 exe 또는 com이다.<br>
반면 유닉스 운영체제에서는 실행 가능 여부를 나타내는 특별한 확장자가 없으며 특별한 옵션 없이 컴파일된 파일은 a.out이다.<br>

### 컴파일러와 인터프리터의 차이
#### 컴파일러
컴파일러를 사용하는 프로그래밍 언어는 사용할 변수를 먼저 선언한 후 코드를 작성하는데 이는 오류를 찾고 코드를 최적화하기 위해 반드시 필요한 작업이다.<br>
컴파일러는 실행 전에 소스코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행파일을 만든다.<br>
크고 복잡한 프로그램에는 컴파일러를 사용한다.<br>
대표적인 언어로 자바가 있다.<br>

#### 인터프리터
인터프리터는 한 줄씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하는 경우나 필요 없는 변수를 확인할 수 없다.<br>
간단한 프로그램에서 주로 사용된다.<br>
대표적인 언어로는 자바스크립트가 있다.<br>
<br>
| 구분 | 자바 | 자바스크립트 |
| --- | --- | --- |
| 언어 유형 | 컴파일 방식의 언어 | 인터프리터 방식의 언어 |
| 변수 | 변수를 선언해야 한다. | 변수를 선언할 필요가 없다. |
| 실행 | 컴파일 후 실행된다. | 한 줄씩 실행된다. |
| 장점 | 오류 찾기와 코드 최적화, 분할 컴파일에 의한 공동 작업이 가능하다. | 실행이 편리하다. |
| 사용 프로그램 | 대형 프로그램 | 간단한 프로그램 |

### 컴파일 과정
컴파일은 사용자가 작성한 소스코드를 목적 코드(object code)로 변환한 후 라이브러리를 연결하고 최종 실행 파일을 만들어 실행하는 과정이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbCWbfU%2FbtrKetwz7ry%2FNt0IsAQ6IblhUfr2i02srk%2Fimg.jpg)<br>

#### ① 소스코드 작성 및 컴파일
개발자가 C언어나 자바로 소스코드를 작성해 컴파일하면 컴퓨터는 0과 1로 이루어진 기계어만 인식할 수 있기 때문에 작성된 소스코드를 컴파일러가 1차적으로 번역하여 목적 코드를 만든다.<br>

#### ② 목적 코드와 라이브러리 연결
목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다. <br>
라이브러리는 자주 사용하는 함수를 시스템 내에 미리 만들어둔 것으로 개발자가 직접 만들기 어렵거나 시간이 많이 걸리는 함수를 파일 형태로 모아놓은 것이다.<br>

#### ③ 동적 라이브러리를 포함하여 최종 실행
실행 시 삽입되는 함수를 동적 라이브러리라고 하는데, 동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요가 없다.<br>함수가 변경되었을 때는 새로운 라이브러리만 사용하여 실행하면 된다.<br>
<br>
윈도우에서는 동적 라이브러리 파일을 DLL(Dynamic Link Loader)이라고 부른다. 윈도우에서 함수의 변경이 일어난 경우, 해당 DLL파일을 구해 특정 폴더에 삽입하면 새로운 기능을 사용할 수 있다. <br>

## 메모리 관리자의 역할
메모리 관리자는 메모리 관리를 담당하며 정확히는 메모리 관리 유닛(Memory Manage Unit; MMU)이라는 하드웨어이다.<br>
메모리 관리자의 작업은 가져오기(fetch), 배치(placement), 재배치(replacement)이다.<br>

### 가져오기 작업
프로세스와 데이터를 메모리로 가져오는 작업이다.<br>
메모리 관리자는 사용자가 요청하면 프로세스와 데이터 모두 메모리로 가져온다. <br>하지만 데이터를 모두 가져오기 어려운 상황에서는 데이터의 일부만 가져와 실행하기도 한다.<br>
또한 메모리 관리자는 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.<br>

### 배치 작업
가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다. <br>
배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요한데 같은 크기로 자르는지, 진행되는 프로세스의 크기에 맞게 자르는지에 따라 메모리 관리의 복잡성이 달라진다.<br>

### 재배치 작업
메모리가 꽉 차있을 경우 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업이다.<br>
<br>
메모리 관리자는 가져오기, 배치, 재배치 작업 시 다음과 같은 정책을 수립하여 그 정책에 따라 메모리를 관리한다.<br>

### 가져오기 정책
프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책이다. <br>
프로세스가 요청할 때 메모리로 가져오는 것이 일반적인 방법이지만, 필요하다고 예상되는 데이터를 미리 가져오는 방법(prefetch)도 있다.<br>

### 배치 정책
가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책이다. <br>
메모리를 같은 크기로 자르는 것을 페이징(paging)이라고 하며, 프로세스의 크기에 맞게 자르는것을 세그먼테이션(segmentation)이라고 한다. <br>
배치 정책은 페이징과 세그먼테이션의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만드는 것이다.<br>

### 재배치 정책
메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책이다. <br>
앞으로 사용하지 않을 프로세스를 내보낼 경우 시스템의 성능이 올라가고 자주 사용하는 프로세스를 내보내면 성능이 떨어진다.<br>
앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘을 교체 알고리즘(replacement algorithm)이라고 한다.<br>
