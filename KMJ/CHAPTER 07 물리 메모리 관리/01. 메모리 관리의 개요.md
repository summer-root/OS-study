# 메모리 관리의 개요
※ 이 장에서 살펴볼 메모리는 메인 메모리를 말한다.<br>

## 메모리 관리의 복잡성
메모리의 구조는 1B로 나뉜다.<br>
1B로 나뉜 각 영역은 메모리 주소로 구분하는데 보통 0번지부터 시작한다.<br>
CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용한다.<br>
메모리 주소 레지스터에 필요한 메모리 주소를 넣으면 데이터를 메모리에서 가져오거나 메모리에 데이터를 옮길 수 있다.<br>
<br>
폰 노이만 구조의 컴퓨터에서 메모리는 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행이 가능하다.<br>
과거의 일괄처리 시스템에서는 한 번에 한 가지 작업만 처리했기 때문에 메모리 관리가 어렵지 않았으나, 오늘날의 시분할 시스템에서는 운영체제를 포함한 모든 응용프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 복잡하다.<br>
<br>
운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.<br>
따라서 메모리에는 사용자 프로세스뿐 아니라 운영체제 프로세스도 공존한다.<br>
컴퓨터가 부팅(컴퓨터를 사용할 수 있는 환경을 마련하는 과정)을 할 때 하드디스크에 저장된 운영체제가 메모리에 올라간다. 부팅이 끝나면 여러 응용 프로그램이 메모리에서 작업을 할 수 있다.<br>
<br>
메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가에 관한 문제로 이러한 복잡한 메모리 관리는 메모리 관리 시스템(Memory Management System; MMS)이 담당한다.<br>

## 메모리 관리의 이중성
프로세스 입장에서는 메모리를 독차지하려하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것을 말한다.<br>
<br>
메모리 관리자 입장의 메모리 공간 관리는 매우 복잡하다. <br>
프로세스가 작업하는 도중에 할당된 공간이 부족할 경우 메모리 관리자는 새로운 공간을 확보하기 위해 옆의 프로세스를 밀어내거나 더 큰 공간으로 해당 프로세스를 옮긴다.<br>
작업을 마치고 난 후 빈공간이 생기면 다음 작업을 위해 빈 공간을 어떻게 처리할지도 결정한다.<br>
이때 빈 공간이 여러개 생길 경우 합쳐서 하나의 큰 공간을 만드는데, 이렇게 하기 위해 현재 작업 중인 공간을 옆으로 밀고 작은 공간을 합쳐나간다.<br>

##### 프로그램을 SSD와 같은 빠르고 큰 저장장치가 아닌 메모리에서 실행하는 이유는?
다른 주변장치보다 비싼 메모리 대신 느리고 값싼 하드디스크를 제2저장장치로 사용하고 비싸고 빠른 메모리는 작업 공간으로 사용한다.<br>
같은 맥락에서 메모리보다 용량은 작지만 CPU 속도로 작동하는 캐시메모리를 추가로 사용하여 전체 시스템의 작업 속도를 빠르게 한다.<br>
<br>
이렇게 메모리를 계층적 구조로 만들어 작업 속도를 올리고 가격을 낮추는 방법을 계층적 메모리 구조라고 한다.<br>

## 소스코드의 번역과 실행
### 컴파일러와 인터프리터의 동작
컴퓨터에서 작동하는 응용프로그램은 프로그래밍 언어로 만들며 보통은 컴파일러를 사용하여 작성한 프로그램을 실행 가능한 코드로 변경한다.<br>
<br>
처음부터 컴퓨터에서 실행 가능한 프로그램을 만들기 위해서는 0과 1로 이루어진 기계어로 만들면 된다.<br>
기계어와 어셈블리어는 컴퓨터의 동작을 가장 직접적으로 표현한 언어로 저급언어(low level language)라고도 하며 배우기 어렵고 이해하기도 어렵다.<br>
저급 언어와 반대되는 개념인 고급언어(high level language)는 사용자가 이해하기 쉽게 프로그래밍할 수 있는 언어로 C언어와 자바가 대표적이다.<br>









