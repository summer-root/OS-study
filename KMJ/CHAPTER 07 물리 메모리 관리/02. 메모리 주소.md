# 메모리 주소
## 32bit CPU와 64bit CPU의 차이
### bit
한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다.<br>
32bit CPU는 한 번에 다룰 수 있는 데이터의 크기가 32bit이고, 64bit CPU는 64bit이다.<br>
CPU의 내부 부품은 모두 이 비트를 기준으로 제작되며 데이터를 전송하는 각종 버스의 크기인 대역폭의 기준도 비트이다.<br>
따라서 32bit 대역폭의 버스를 통해 한 번에 옮겨지는 데이터의 크기는 32bit이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbmvPEi%2FbtrJ8nrlKPM%2FNeZgUioxEAs8KH0EAfYlEk%2Fimg.png)<br>

CPU의 비트는 메모리 주소 공간의 크기와도 관련이 있다.<br>
32bit CPU의 경우 메모리 주소를 지정하는 레지스터인 메모리 주소 레지스터(MAR)의 크기가 32bit이므로 표현할 수 있는 메모리 주소의 범위가 0~2³²-1, 총개수가 2³²이며 총크기는 2³²B로 약 4GB이다.<br>
64bit CPU는 레지스터의 크기, 버스의 대역폭, 한 번에 처리되는 데이터의 최대 크기 등이 32bit CPU의 2배이다.<br>
따라서 32bit CPU보다 처리속도가 빠르고 사용할 수 있는 메모리도 크다.<br>
<br>
컴퓨터에는 메모리가 설치되며 각 메모리 주소 공간이 있는데 이 공간을 물리 주소 공간(physical address space)이라고 한다.<br>
물리 주소 공간은 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다르다.<br>
이와 반대로 사용자 입장에서 바라본 주소 공간은 논리 주소 공간(logical address space)이라고 한다.<br>

## 절대 주소와 상대 주소
### 메모리 영역의 구분
#### 단순 메모리 구조
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fn64Ov%2FbtrKn7uHaGL%2F7Pekkvi6TqAQVTYw0iPkZ0%2Fimg.png)<br>
한 번에 한 가지 일만 처리하는 일괄처리 시스템에서 볼 수 있다.<br>
메모리 관리자는 이러한 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리한다. <br>
운영체제는 시스템을 관리하는 중요한 역할을 하기 때문에 사용자가 운영체제를 침범하지 못하도록 분리하여 사용한다.<br>
<br>
사용자 프로세스는 운영체제 영역을 피해 메모리에 적재된다.<br>
사용자 프로세스가 운영체제의 크기에 따라 매번 적재되는 주소가 달라지는 것은 번거로운 일이기 때문에 사용자 프로세스를 메모리의 최상위에서부터 운영체제 방향으로 내려오면서 사용하는 방법이 있다.<br>
이 방법은 운영체제의 크기에 상관없이 사용자 영역의 시작점을 결정할 수 있으나 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡하기 때문에 잘 쓰이지 않는다.<br>

#### 경계 레지스터
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbaEPK1%2FbtrKqFcHwdW%2F7dy0XLgh289AMBtXmH95ck%2Fimg.png)<br>

사용자 영역이 운영체제 영역으로 침범하는 것을 막으려면 하드웨어의 도움이 필요한데, 이는 CPU 내에 있는 경계 레지스터가 담당한다.<br>
경계 레지스터는 운영체제 영역과 사용자 영역 경계지점의 주소를 가진 레지스터이다.<br>
메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사하고 경계 레지스터를 벗어나는 작업을 요청하는 프로세스가 있을 경우 그 프로세스를 종료한다.<br>

## 절대 주소와 상대 주소의 개념
### 절대 주소 (absolute address)
실제 물리 주소(physical address)를 가리킨다.<br>
메모리 관리자 입장에서 바라본 주소이다.<br>
즉 메모리 주소 레지스터가 사용하는 주소로, 컴퓨터에 꽂힌 램 메모리의 실제 주소를 말한다.<br>
사용자 입장에서는 절대 주소 사용 시 매번 운영체제 영역을 확인해야 해서 불편하고 운영체제 영역의 주소가 사용자에게 노출되면 실수나 고의적인 조작으로 운영체제 영역을 침범할 수 있기 때문에 위험하다.<br>

### 상대 주소 (relative address)
사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소 지정 방식이다.<br>
사용자 프로세스 입장에서 바라본 주소이며, 절대 주소와 관계없이 항상 0번지부터 시작하는데 이러한 주소 공간을 논리 주소 공간이라고 부른다.<br>
상대 주소 사용 시 프로세스 입장에서 상대 주소가 사용할 수 없는 영역의 위치를 알 필요가 없고, 주소가 항상 0번지부터 시작하기 때문에 편리하다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDVJKH%2FbtrKk9zCgG3%2FBgbEnFFfRiSpkEk6MDtxyK%2Fimg.png)<br>

## 상대 주소를 절대 주소로 변환하는 과정
메모리 접근 시 절대 주소를 사용하면 특별한 변환 과정 없이 작업을 할 수 있지만 상대 주소를 사용하면 상대 주소를 실제 메모리 내의 물리 주소인 절대 주소로 변환해야 한다.<br>
이러한 변환 작업은 프로세스가 실행되는 동안 메모리 관리자가 매우 빠르게 처리한다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FydyYk%2FbtrKpP72NTC%2FCaHbuz6mBxqo5K7G9bLC6K%2Fimg.png)<br>

1. 사용자 프로세스가 상대 주소 40번지에 있는 데이터를 요청한다.
2. CPU는 메모리 관리자에게 40번지에 있는 내용을 가져오라고 명령한다.
3. 메모리 관리자는 재배치 레지스터를 사용하여 상대 주소 40번지를 절대 주소 400번지로 변환하고 메모리 400번지에 저장된 데이터를 가져온다.
<br>
메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소 값에 재배치 레지스터 값을 더해 절대 주소를 구한다.<br>
재배치 레지스터는 주소 변환의 기본이 되는 주소 값을 가진 레지스터로, 메모리에서 사용자 영역의 시작 주소 값이 저장된다.<br>
사용자 프로세스 입장에서는 메모리 관리자가 재배치 레지스터를 사용하여 상대 주소를 절대 주소로 변환하기 때문에 메모리가 항상 0번지부터 시작하는 연속된 작업 공간으로 보인다.<br>







