# 파일, 파이프, 소켓 프로그래밍
## 파일
### 순차파일
파일 내의 데이터는 한 줄로 길게 저장되는데 이러한 파일을 순차파일(sequential file)이라고 하고, 순차파일에 접근하는 방식을 순차적 접근(sequential access)이라한다.<br>
순차적 접근의 대표적인 예로는 카세트테이프를 들 수 있다. <br>

### 파일 기술자
파일을 포함하여 모든 통신에 관련된 연산은 open(), read()/write(), close() 구조다.<br>
```c
#include <studio.h>
#include <unistd.h>
#include <fcntl.h>
 
void main()
{    int fd;
    char buf[5];
 
    fd=open("com.txt", O_RDWR); // com.txt를 읽기/쓰기 전용으로 연다 
                                // * O_RDWR : 파일을 읽기/쓰기용으로 연다.
    read(fd, buf, 5); // 파일에서 5번째 파일 기술자의 위치를 읽어 해당 값을 변수 buf에 저장 
    printf("%s", buf); 
    close(fd);
    return 0;
}

```
- open() : 열고자 하려는 파일이 있는지, 그 파일이 있다면 접근권한이 있는지, 파일을 어떤 방식으로 열것인지를 결정한다. 파일을 여는 방식에는 읽기 전용(read only), 읽기/쓰기(read/write), 쓰기 전용(write only), 생성(create)등이 있다.<br>

파일 기술자는 파일 접근 권한 외에 현재 파일의 어느 위치를 읽고 있는지에 대한 정보도 보관한다.<br>
처음 파일이 열리면 파일 기술자는 맨 앞에 위치한다. 파일에서 파일 기술자는 단 하나이고, 읽기를 하든 쓰기를 하든 파일 기술자는 계속 전진한다.<br>
<br>
파일을 다 사용하고 close() 함수를 사용하면 파일이 닫힌다. <br>

### 파일을 이용한 통신
부모 프로세스와 자식 프로세스가 파일을 이용하여 통신을 하는 코드이다.<br>
```c
#include <studio.h>
#include <unistd.h>
#include <fcntl.h>
 
void main()
{   int pid, fd;
    char buf[5];
 
    fd=open("com.txt", O_RDWR);         /* init */
    // fork()문을 실행하기 전에 파일을 open()한다.(= 생성된 파일 기술자가 자식 프로세스에도 상속된다)
    pid=fork(); //fork
 
    if(pid<0 || fd<0) exit(-1);
 
    else if(pid==0) {                    /* child */
        write(fd, "Test", 5); /* 파일 com.txt에 Test라고 쓴다. 
                                 여기서 Test는 4B이지만 널문자(\0)이 필요하기때문에 5B할당한다. */                                                  
        close(fd); // 파일 기술자 닫고 종료
        exit(0); }
 
    else {  wait(0);                    /* parent */
            lseek(fd, 0, SEEK_SET);
            read(fd, buf, 5);
            printf("%s", buf);
            close(fd);
            exit(0); }
}

부모 프로세스가 자식 프로세스보다 먼저 실행되면 자식 프로세스가 아무 작업도 하지 않았기때문에 빈 공간을 읽게 된다.<br>
따라서 부모 프로세스와 자식 프로세스간에 동기화를 해주어야 한다.<br>
부모 프로세스는 자식 프로세스의 작업이 끝난 후 read()를 수행해야 하기때문에 wait()를 사용하여 자식 프로세스를 기다린다.<br>
자식 프로세스가 작업을 마치면 lseek()가 실행되어 파일 기술자가 맨 앞으로 옮겨진다. 그 후 읽은 데이터를 화면에 출력하며 파일 기술자를 닫고 프로그램을 끝낸다.<br>
<br>
파일기술자(file descriptor; fd)은 해당 파일에 접근할 수 있는 권리로 이 변수를 통해서만 파일 읽기/쓰기에 접근 할 수 있다.<br>
fork()는 부모 프로세스의 대부분을 자식 프로세스에도 그대로 복사해주는데 파일 기술자도 이에 포함된다. 파일 기술자가 자식 프로세스에도 복사되므로 부모와 자식 프로세스 모두 com.txt를 읽거나 쓸수 있다.<br>
이처럼 파일 기술자가 자식프로세스에도 복사되기때문에 open()은 한번(init)이지만 close()는 자식 프로세스에서 한번, 부모 프로세스에서 한번 두번 발생한다.<br>
<br>
lseek()는 파일 기술자 fd를 임의로 움직이는 명령어로 움직이는 기준점을 정할 수있다.<br>
- SEEK_SET : 파일의 맨 처음 위치
- SEEK_CUR : 파일 기술자의 현재위치
- SEEK_END : 파일의 매 마지막 위치가 기준이다.
