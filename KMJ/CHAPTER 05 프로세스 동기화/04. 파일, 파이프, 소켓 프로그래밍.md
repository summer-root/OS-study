# 파일, 파이프, 소켓 프로그래밍
## 파일
### 순차파일
파일 내의 데이터는 한 줄로 길게 저장되는데 이러한 파일을 순차파일(sequential file)이라고 하고, 순차파일에 접근하는 방식을 순차적 접근(sequential access)이라한다.<br>
순차적 접근의 대표적인 예로는 카세트테이프를 들 수 있다. <br>

### 파일 기술자
파일을 포함하여 모든 통신에 관련된 연산은 open(), read()/write(), close() 구조다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSXT1n%2FbtrI2wioPHH%2FURRTDLw58Rg1BvhfRyIhbK%2Fimg.png)<br>

- open() : 열고자 하려는 파일이 있는지, 그 파일이 있다면 접근권한이 있는지, 파일을 어떤 방식으로 열것인지를 결정한다. 파일을 여는 방식에는 읽기 전용(read only), 읽기/쓰기(read/write), 쓰기 전용(write only), 생성(create)등이 있다.<br>

파일 기술자는 파일 접근 권한 외에 현재 파일의 어느 위치를 읽고 있는지에 대한 정보도 보관한다.<br>
처음 파일이 열리면 파일 기술자는 맨 앞에 위치한다. 파일에서 파일 기술자는 단 하나이고, 읽기를 하든 쓰기를 하든 파일 기술자는 계속 전진한다.<br>
<br>
파일을 다 사용하고 close() 함수를 사용하면 파일이 닫힌다. <br>

### 파일을 이용한 통신
부모 프로세스와 자식 프로세스가 파일을 이용하여 통신을 하는 코드이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmV2DS%2FbtrI2ebffJg%2FV0jVUIiur8oCCiRQ0HPtK1%2Fimg.png)<br>

부모 프로세스가 자식 프로세스보다 먼저 실행되면 자식 프로세스가 아무 작업도 하지 않았기때문에 빈 공간을 읽게 된다.<br>
따라서 부모 프로세스와 자식 프로세스간에 동기화를 해주어야 한다.<br>
부모 프로세스는 자식 프로세스의 작업이 끝난 후 read()를 수행해야 하기때문에 wait()를 사용하여 자식 프로세스를 기다린다.<br>
자식 프로세스가 작업을 마치면 lseek()가 실행되어 파일 기술자가 맨 앞으로 옮겨진다. 그 후 읽은 데이터를 화면에 출력하며 파일 기술자를 닫고 프로그램을 끝낸다.<br>
<br>
파일기술자(file descriptor; fd)은 해당 파일에 접근할 수 있는 권리로 이 변수를 통해서만 파일 읽기/쓰기에 접근 할 수 있다.<br>
fork()는 부모 프로세스의 대부분을 자식 프로세스에도 그대로 복사해주는데 파일 기술자도 이에 포함된다. 파일 기술자가 자식 프로세스에도 복사되므로 부모와 자식 프로세스 모두 com.txt를 읽거나 쓸수 있다.<br>
이처럼 파일 기술자가 자식프로세스에도 복사되기때문에 open()은 한번(init)이지만 close()는 자식 프로세스에서 한번, 부모 프로세스에서 한번 두번 발생한다.<br>
<br>
lseek()는 파일 기술자 fd를 임의로 움직이는 명령어로 움직이는 기준점을 정할 수있다.<br>
- SEEK_SET : 파일의 맨 처음 위치
- SEEK_CUR : 파일 기술자의 현재위치
- SEEK_END : 파일의 매 마지막 위치가 기준이다.

------------

## 파이프
동기화를 지원하는 단방향 통신 시스템으로, 이름 없는 파이프와 이름 있는 파이프로 나뉜다. 일반적으로 파이프는 이름 없는 파이프를 말한다. 파이프는 부모와 자식 프로세스 혹은 같은 부모의 자식 프로세스처럼 서로 관련 있는 프로세스 간 통신에 사용된다. <br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8HVzQ%2FbtrI6rUPFJc%2FfhQGbSMYigbhKGLnBD51Uk%2Fimg.png)<br>
파일의 경우와 마찬가지로 파이프도 기술자를 초기화한 후 읽거나 쓰기 연산을 하고 close()로 기술자를 닫는 구조이다.<br>
파이프는 파일 기술자를 2개의 원소를 가진 배열로 정의하는데, 하나는 읽기용이고 하나는 쓰기용이다. 이렇게 두 기술자가 따로 존재하기 때문에 동기화가 가능하다.<br>
fd[2]를 선언한 후 fork() 시 총 4개의 파일 기술자가 존재하게 된다. 따라서 close()도 4개 존재한다.<br>
파이프는 단방향 통신이기 때문에 프로세스 당 하나의 파일 기술자만 사용한다. 따라서 필요 없는 파일 기술자는 닫아버린다.<br>
위 코드에서는 자식 프로세스가 fd[1]에 쓰고 부모 프로세스가 fd[0]으로 받는 구조이므로, 자식 프로세스는 사용하지 않을 fd[0]을 닫고 부모 프로세스는 fd[1]을 닫는다.<br>
<br>
파이프 기술자가 4개이기 때문에 파이프 기술자를 닫을 것이 아니라 양방향 통신에 이용하면 된다고 생각할 수도 있지만, 자신이 write 한 것을 자신이 read 한 것이기 때문에 부모 프로세스에 쓰고자 한 데이터가 전달되지 않는다.<br>
파이프로 양방향 통신을 구현하려면 파이프를 2개 사용해야 한다. <br>
<br>
파이프의 또 다른 특징으로는 부모 프로세스에 wait()이 없다는 것이다. <br>wait()리 없으면 부모 프로세스와 자식 프로세스 중 어떤 프로세스가 먼저 실행되는지 보장할 수 없지만 파이프는 대기가 있는 통신이기 때문에 wait()가 필요 없다.<br>

------------
## 네트워킹
여러 컴퓨터에 있는 프로세스에 데이터를 전달하는 방법 중 가장대중화된 방식으로 소켓을 이용한 네트워킹에도 open(), read()/write(), close() 구조를 사용한다.<br>
클라이언트와 서버는 둘다  소켓을 사용하며, 소켓은 파이프와 달리 양방향 통신을 지원하고 동기화도 지원한다. <br>















