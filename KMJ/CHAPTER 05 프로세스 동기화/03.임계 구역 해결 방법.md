# 임계 구역 해결 방법
임계 구역을 해결하는 가장 단순한 방법은 잠금 lock을 이용하고, 잠금해제와 동시에 동기화 신호를 보낸다. <br>

## 기본 코드 소개
소프트웨어적으로 임계 구역을 해결하는 방법이다.<br>

------------


## 해결 조건을 고려한 코드 설계
### 상호 배제 문제
프로세스 P1과 P2는 코드가 같으며 두 프로세스가 공유하는 변수인 lock의 초깃값은 false이다.<br> 여기서 false는 잠금이 해제되었다는 의미이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FQBf19%2FbtrIRGxGuOO%2FexpqevMmH6mJBLVQlrqeO1%2Fimg.png)<br>

    프로세스 P1과 P2는 임계 구역에 진입하기 전에 코드를 통해 임계 구역에 잠금이 걸려있는지 확인한다(lock==true).
    임계 구역이 잠겨있을 경우 다른 프로세스가 임계 구역에서 잠겨있다는 의미이므로 잠금이 해제될 때까지 무한 루프를 돌면서 기다린다. [while(lock==true);].
    임계 구역에 있는 프로세스가 작업을 마치고 작업을 해제하면(lock=false;) 무한 루프를 빠져나와 작업을 한다.
    잠금이 풀려 새로 임계구역에 진입하는 프로세스는 다른 프로세스가 접근하지 못하도록 잠금을 걸고 작업을 하며, 작업을 마치면 다른 프로세스가 사용할 수 있도록 잠금을 해제한다.
	
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fv3JmO%2FbtrIO1WCTNA%2FrAQJzzmTOyyTlOwWcFYxC1%2Fimg.png)<br>
임계 구역에 진입한 프로세스가 없고(lock=false;) 다음과 같이 실행될 경우 제대로 작동하지 않는다. <br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fv3JmO%2FbtrIO1WCTNA%2FrAQJzzmTOyyTlOwWcFYxC1%2Fimg.png)<br>
    1. 프로세스 P1은 while(lock==true);문을 실행한다. 임계 구역에 프로세스가 없기 때문에 무한 루프를 빠져나온다. 그런데 이어서 다음 문장을 실행하려는 순간 자신에게 주어진 CPU 시간을 다 써서(타임아웃) 준비상태로 옮겨진다. 문맥 교환이 발생하고 프로세스 P2가 실행상태로 바뀐다.
    2. 프로세스 P2는 while(lock==true);문을 실행한다. 아직 프로세스 P1이 잠금을 걸지 않았기 때문에 lock은 여전히 false이며 프로세스 P2는 임계 구역에 진입할 수 있다.
    3. 프로세스 P1은 lock=true;문을 실행하여 임계구역에 잠금을 걸고 진입한다.
    4. 프로세스 P2도 lock=true;문을 실행하여 임계 구역에 잠금을 걸고 진입한다. 결국 둘 다 임계 구역에 진입하게 된다.
<br>
위와 같은 상황은 상호 배제 조건을 보장하지 못하며, 잠금이 풀리기를 기다리면 바쁜대기를 해 시스템 자원을 낭비하게 된다는 문제가 있다.<br>


### 한정 대기 문제
상호 배제를 보장하지 못하는 문제를 보완하여 작성한 코드이다. 전역 변수로 lock1과 lock2를 사용하며 둘의 초깃값은 false이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fnk5nA%2FbtrIO13oVf7%2FQm6K5oMFna51oVBMoH1ztk%2Fimg.png)<br>
    프로세스 P1은 임계 구역에 진입하기 전에 먼저 잠금을 설정하고(lock1=true;) 프로세스 P2가 잠금을 설정했는지 확인한다. [while(lock2==true);]
    만약 잠금을 설정하지 않았다면 임계 구역에 진입하여 작업을 마친 후 잠금을 해제한다(lock1=false;).
    프로세스 P2도 같은 방식으로 임계구역에 진입한다.

잠금을 2개 사용하여 일단 잠금을 하고 다른 프로세스가 잠겼는지 확인하므로 두 프로세스의 상호 배제가 보장된다.<br> 하지만 이 코드는 두 프로세스 모두 임계 구역에 진입하지 못하는 무한 대기 현상이 일어난다.  <br>

    1. 프로세스 P1은 lock1=true; 문을 실행한 후 자신의 CPU 시간을 다 써버렸다(타임아웃). 문맥 교환이 발생하고 프로세스 P2가 실행상태로 바뀐다.
    2. 프로세스 P2도 lock2=true;문을 실행한 후 자신의 CPU 시간을 다 써버렸다(타임아웃). 문맥 교환이 발생하고 프로세스 P1이 실행상태로 바뀐다.
    3. 프로세스 P2가 lock2=true;문을 실행했기 때문에 프로세스 P1은 while(lock2==true);문에서 무한 루프에 빠진다.
    4. 프로세스 P1이 lock1=true;문을 실행했기때문에 프로세스 P2도 while(lock1==true);문에서 무한 루프에 빠진다.

결국 프로세스 P1과 P2 모두 while문을 빠져나오지 못하고 무한 루프에 빠져 임계 구역에 진입하지 못한다. <br>이는 한정 대기 조건을 보장하지 못하는 상황으로 교착상태(deadlock)라고 한다. 교착상태는 프로세스가 살아있으나 작업이 진행되지 못하는 상태를 말한다.<br>
<br>
또한 위 코드에는 프로세스가 늘어나면 검사해야 하는 lcok의 개수 또한 늘어나 비효율적인 확장성 문제가 있다. <br>

### 진행의 융통성 문제
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fea0S7R%2FbtrISBv4b5r%2FNIJ6G7sp5vKjRPJZNOvDRk%2Fimg.png)<br>
    공유 변수 lock의 값을 통해 다른 프로세스가 임계 구역에 있는지 확인하고, 없으면 진입한다.
    프로세스 P1은 while(lock==2);문을 실행하고 프로세스 P2가 잠금을 걸었으면 기다린다. 여기에서는 lock=1이기 때문에 프로세스 P1이 임계 구역에 진입하고, 임계 구역을 빠져나올 때 lock을 2로 바꾼다.

이 코드는 잠금을 확인하는 문장이 하나이므로 상호 배제와 한정 대기를 보장하지만 서로 번갈아가면서 실행된다는 것이 문제이다.<br>이렇게 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 경직된 동기화(lockstep synchronization)라고 한다.<br> 즉, 진행의 융통성을 보장하지 못한다.<br>

### 하드웨어적인 해결 방법
이 코드는 잠금이 걸렸는지 검사하는 while(lock==true);문과 검사한후 잠금 설정을 하는 lock=true;문이 분리되어 실행되면(두 명령어 중간에 타임아웃이 걸리면) 문제가 발생한다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdD6uLj%2FbtrILfuKY5N%2F1XRQaYuW23JYhoOC7pzqv0%2Fimg.png)<br>
왼쪽 코드의 1행과 2행은 오른쪽 코드의 1행과 같다. <br>이는 검사와 지정(test-and-set)이라는 코드로 하드웨어의 지원을 받아 while(lock==true);문과 lock=true;문을 한꺼번에 실행한다. <br>검사와 지정 코드를 이용하면 명령어 실행 중간에 타임아웃이 걸려 임계구역을 보호하지 못하는 문제가 발생하지 않는다.<br>
이 방법은 편리하지만 바쁜 대기를 사용하여 검사하기때문에 자원 낭비가 있다.<br>




