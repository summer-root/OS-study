# 임계 구역 해결 방법
임계 구역을 해결하는 가장 단순한 방법은 잠금 lock을 이용하고, 잠금해제와 동시에 동기화 신호를 보낸다. <br>

## 기본 코드 소개
소프트웨어적으로 임계 구역을 해결하는 방법이다.<br>

------------


## 해결 조건을 고려한 코드 설계
### 상호 배제 문제
프로세스 P1과 P2는 코드가 같으며 두 프로세스가 공유하는 변수인 lock의 초깃값은 false이다.<br> 여기서 false는 잠금이 해제되었다는 의미이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FQBf19%2FbtrIRGxGuOO%2FexpqevMmH6mJBLVQlrqeO1%2Fimg.png)<br>

    프로세스 P1과 P2는 임계 구역에 진입하기 전에 코드를 통해 임계 구역에 잠금이 걸려있는지 확인한다(lock==true).
    임계 구역이 잠겨있을 경우 다른 프로세스가 임계 구역에서 잠겨있다는 의미이므로 잠금이 해제될 때까지 무한 루프를 돌면서 기다린다. [while(lock==true);].
    임계 구역에 있는 프로세스가 작업을 마치고 작업을 해제하면(lock=false;) 무한 루프를 빠져나와 작업을 한다.
    잠금이 풀려 새로 임계구역에 진입하는 프로세스는 다른 프로세스가 접근하지 못하도록 잠금을 걸고 작업을 하며, 작업을 마치면 다른 프로세스가 사용할 수 있도록 잠금을 해제한다.
	
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fv3JmO%2FbtrIO1WCTNA%2FrAQJzzmTOyyTlOwWcFYxC1%2Fimg.png)<br>
임계 구역에 진입한 프로세스가 없고(lock=false;) 다음과 같이 실행될 경우 제대로 작동하지 않는다. <br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fv3JmO%2FbtrIO1WCTNA%2FrAQJzzmTOyyTlOwWcFYxC1%2Fimg.png)<br>
    1. 프로세스 P1은 while(lock==true);문을 실행한다. 임계 구역에 프로세스가 없기 때문에 무한 루프를 빠져나온다. 그런데 이어서 다음 문장을 실행하려는 순간 자신에게 주어진 CPU 시간을 다 써서(타임아웃) 준비상태로 옮겨진다. 문맥 교환이 발생하고 프로세스 P2가 실행상태로 바뀐다.
    2. 프로세스 P2는 while(lock==true);문을 실행한다. 아직 프로세스 P1이 잠금을 걸지 않았기 때문에 lock은 여전히 false이며 프로세스 P2는 임계 구역에 진입할 수 있다.
    3. 프로세스 P1은 lock=true;문을 실행하여 임계구역에 잠금을 걸고 진입한다.
    4. 프로세스 P2도 lock=true;문을 실행하여 임계 구역에 잠금을 걸고 진입한다. 결국 둘 다 임계 구역에 진입하게 된다.
<br>
위와 같은 상황은 상호 배제 조건을 보장하지 못하며, 잠금이 풀리기를 기다리면 바쁜대기를 해 시스템 자원을 낭비하게 된다는 문제가 있다.<br>


### 한정 대기 문제
상호 배제를 보장하지 못하는 문제를 보완하여 작성한 코드이다. 전역 변수로 lock1과 lock2를 사용하며 둘의 초깃값은 false이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fnk5nA%2FbtrIO13oVf7%2FQm6K5oMFna51oVBMoH1ztk%2Fimg.png)<br>
    프로세스 P1은 임계 구역에 진입하기 전에 먼저 잠금을 설정하고(lock1=true;) 프로세스 P2가 잠금을 설정했는지 확인한다. [while(lock2==true);]
    만약 잠금을 설정하지 않았다면 임계 구역에 진입하여 작업을 마친 후 잠금을 해제한다(lock1=false;).
    프로세스 P2도 같은 방식으로 임계구역에 진입한다.

잠금을 2개 사용하여 일단 잠금을 하고 다른 프로세스가 잠겼는지 확인하므로 두 프로세스의 상호 배제가 보장된다.<br> 하지만 이 코드는 두 프로세스 모두 임계 구역에 진입하지 못하는 무한 대기 현상이 일어난다.  <br>

    1. 프로세스 P1은 lock1=true; 문을 실행한 후 자신의 CPU 시간을 다 써버렸다(타임아웃). 문맥 교환이 발생하고 프로세스 P2가 실행상태로 바뀐다.
    2. 프로세스 P2도 lock2=true;문을 실행한 후 자신의 CPU 시간을 다 써버렸다(타임아웃). 문맥 교환이 발생하고 프로세스 P1이 실행상태로 바뀐다.
    3. 프로세스 P2가 lock2=true;문을 실행했기 때문에 프로세스 P1은 while(lock2==true);문에서 무한 루프에 빠진다.
    4. 프로세스 P1이 lock1=true;문을 실행했기때문에 프로세스 P2도 while(lock1==true);문에서 무한 루프에 빠진다.

결국 프로세스 P1과 P2 모두 while문을 빠져나오지 못하고 무한 루프에 빠져 임계 구역에 진입하지 못한다. <br>이는 한정 대기 조건을 보장하지 못하는 상황으로 교착상태(deadlock)라고 한다. 교착상태는 프로세스가 살아있으나 작업이 진행되지 못하는 상태를 말한다.<br>
<br>
또한 위 코드에는 프로세스가 늘어나면 검사해야 하는 lcok의 개수 또한 늘어나 비효율적인 확장성 문제가 있다. <br>

### 진행의 융통성 문제
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fea0S7R%2FbtrISBv4b5r%2FNIJ6G7sp5vKjRPJZNOvDRk%2Fimg.png)<br>
    공유 변수 lock의 값을 통해 다른 프로세스가 임계 구역에 있는지 확인하고, 없으면 진입한다.
    프로세스 P1은 while(lock==2);문을 실행하고 프로세스 P2가 잠금을 걸었으면 기다린다. 여기에서는 lock=1이기 때문에 프로세스 P1이 임계 구역에 진입하고, 임계 구역을 빠져나올 때 lock을 2로 바꾼다.

이 코드는 잠금을 확인하는 문장이 하나이므로 상호 배제와 한정 대기를 보장하지만 서로 번갈아가면서 실행된다는 것이 문제이다.<br>이렇게 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 경직된 동기화(lockstep synchronization)라고 한다.<br> 즉, 진행의 융통성을 보장하지 못한다.<br>

### 하드웨어적인 해결 방법
이 코드는 잠금이 걸렸는지 검사하는 while(lock==true);문과 검사한후 잠금 설정을 하는 lock=true;문이 분리되어 실행되면(두 명령어 중간에 타임아웃이 걸리면) 문제가 발생한다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdD6uLj%2FbtrILfuKY5N%2F1XRQaYuW23JYhoOC7pzqv0%2Fimg.png)<br>

    왼쪽 코드의 1행과 2행은 오른쪽 코드의 1행과 같다. 이는 검사와 지정(test-and-set)이라는 코드로 하드웨어의 지원을 받아 while(lock==true);문과 lock=true;문을 한꺼번에 실행한다. 검사와 지정 코드를 이용하면 명령어 실행 중간에 타임아웃이 걸려 임계 구역을 보호하지 못하는 문제가 발생하지 않는다.

이 방법은 편리하지만 바쁜 대기를 사용하여 검사하기때문에 자원 낭비가 있다.<br>


------------
## 피터슨 알고리즘
임계 구역 문제를 해결하기 위해 게리 피터슨이 제안한 것으로 구조가 복잡하여 현재 잘 사용되지 않는다. 
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbEL06J%2FbtrI2Y55Tms%2FbCZVmwnpbjUH8ch6PKqNT0%2Fimg.png)<br>

    프로세스 P1은 임계 구역에 진입하기 전에 먼저 잠금을 한 후(lock1=true), turn을 2로 설정한다. 
    변수 turn은 두 프로세스가 동시에 lock을 설정하여 임계 구역에 못 들어가는 상황에 대비하기 위한 장치로 두 프로세스가 동시에 lock을 설정했더라도 turn을 사용해 다른 프로세스에 양보할 수 있도록 한다.
    이어서 while(lock2==true && turn ==2);를 실행해 프로세스 P2가 잠금을 설정하지 않았거나 잠금을 설정했더라도 곧바로 turn=1로 바꾸면 프로세스 P1은 임계 구역에 진입하여 작업을 마친 후 잠금을 해제하고 임계 구역을 빠져나온다.
    프로세스 P2도 같은 방식으로 임계 구역에 진입한다.

피터슨 알고리즘은 임계구역 해결의 세 가지 조건을 모두 만족하지만 2개의 프로세스만 가능하다는 한계가 있으며, 여러 프로세스가 하나의 임계 구역을 사용하려면 공유 변수를 추가하고 코드를 변경해야 한다.<br>

------------
## 데커 알고리즘
데오도뤼스 데커가 제안한 알고리즘으로 임계 구역 해결의 세 가지 조건을 모두 만족하며 하드웨어의 도움 없이도 임계 구역의 문제를 해결할 수 있다는 특징이 있다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbgnj4K%2FbtrI2c4Sgx5%2F5Dl20kXu1kWKYxhe3IOLj1%2Fimg.png)<br>

    1. 프로세스 P1은 우선 잠금을 건다. (lock1=true;)
    2. 프로세스 P2의 잠금이 걸렸는지 확인한다. [while(lock2==true)]
    3. 만약 프로세스 P2도 잠금을 걸었다면 누가 먼저인지 확인한다 [if(turn==2)]. 만약 프로세스 P1의 차례라면(turn=1) 임계 구역으로 진입한다. 만약 프로세스 P2의 차례라며(turn=2;) ④로 이동한다.
    4. 프로세스 P1의 잠금을 풀고(lock1=false;) 프로세스 P2가 작업을 마칠 때까지 기다린다 [while(turn==2);]. 프로세스 P2가 작업을 마치면 잠금을 걸고(lcok1=true); 임계 구역으로 진입한다.

피터슨 알고리즘이나 데커 알고리즘은 임계 구역 해결의 세 가지 조건을 모두 만족하지만 매우 복잡하며, 프로세스가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다.<br> 임계 구역을 보호하기 위해 복잡한 알고리즘을 구현하도록 주문하는 것은 바람직하지 않다. <br>

------------
## 세마포어
바쁜 대기를 사용하여 자원을 낭비하고 복잡한 알고리즘을 가진 이전의 임계 구역 해결 알고리즘의 단점을 해결하기 위해 에츠허르 데이크스트라가 제안한 알고리즘이다.<br>
세마포어는 임계 구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계 구역으로 들어간다. <br>
이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다. 프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계 구역을 사용하라는 동기화 신호를 보낸다. <br>세마포어는 다른 알고리즘과 달리 임계 구역이 잠겼는지 직접 점검하거나, 바쁜 대기를 하거나, 다른 프로세스에 동기화 메시지를 보낼 필요가 없다.<br>
세마포어는 공유자원이 여러개일때도 사용할 수 있다. 공유자원이 2개일 경우 Semaphore(n)의 초기값은 2이다.<br>
<br>
세마포어의 가장 큰 문제점으로는 잘못된 사용으로 인해 임계 구역이 보호받지 못한다는 점이다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdFgt2k%2FbtrI6dg4SSt%2FSqf2Q5tWQTFkpzFJyZZ2Zk%2Fimg.png)<br>

- Semaphore(n) : 전역변수 RS를 n으로 초기화한다. RS에는 현재 사용 가능한 자원의 수가 저장된다.
- P() : 잠금을 수행하는 코드로, RS가 0보다 크면(사용 가능한 자원이 있으면) 1만큼 감소시키고 임계 구역에 진입한다. 만약 RS가 0보다 작으면(사용 가능한 자원이 없으면) 0보다 커질 때까지 기다린다.
- V() : 잠금해제와 동기화를 같이 수행하는 코드로, RS값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계 구역에 진입해도 좋다는 wake_up 신호를 보낸다.
- block() : 대기시 사용한다.

    세마포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어있다가 wake_up 신호를 받으면 큐에서 나와 임계 구역에 진입한다. 따라서 바쁜 대기를 하는 프로세스가 없다. 그러나 세마포어의 P(), V() 내부 코드가 실행되는 도중에 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못한다. 그러므로 P()와 V()의 내부 코드는 검사와 지정을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 한다. 

------------
## 모니터
세마포어는 피터슨 알고리즘이나 데커 알고리즘보다 단순하고 사용하기 편리하지만 사용자가 고의로 세마포어를 사용하지 않거나 사용 중의 실수로 인해 임계 구역이 보호받지 못하는 문제가 있다. <br>
공유자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 굳이 P()와 V()를 사용할 필요없이 자동으로 처리하면 된다. 이를 실제로 구현한 것이 모니터 monitor이다.<br>
모니터는 공유자원을 내부적으로 숨기고 공유자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시킨다.<br>
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb8dFCU%2FbtrI7MD9j6O%2Fkw5Gtfk4PgFr6UGuvZNhmK%2Fimg.png)<br>
