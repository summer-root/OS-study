# 임계구역 해결 방법

임계구역 문제를 해결하는 단순한 방법은 lock을 이용하는 것이다. 

<br>



## 기본 코드 소개

소프트웨어적으로 임계구역을 해결하는 방법

```c
#include <stdio.h>

typedef enum {false, true} boolean; // boolean 타입 정의
extern boolean lock = false;
extern int balance;

main(){
    while(lock == true); // 무한루프
    lock = true;
    balance = balance + 10;
    lock = false;
}
```

** 해당 코드에서는 C언어에 boolean 변수가 없어 enum을 이용하여 정의했지만, C99부터 stdbool.h 헤더를 include 하면 bool 타입을 사용할 수 있다.

<br>



## 임계구역 해결 조건을 고려한 코드 설계

### 상호 배제 문제

다음은 임계구역 문제를 해결하기 위한 첫 번째 코드이다. 프로세스 P1과 P2는 코드가 같으며 두 프로세스가 공유하는 변수인 lock의 초기값은 false이다. 여기에서 false는 잠금이 해제되었다는 의미이다.

![전역 변수로 잠금을 구현한 코드](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2005%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%A0%84%EC%97%AD%20%EB%B3%80%EC%88%98%EB%A1%9C%20%EC%9E%A0%EA%B8%88%EC%9D%84%20%EA%B5%AC%ED%98%84%ED%95%9C%20%EC%BD%94%EB%93%9C.png)

1. 프로세스 P1과 P2는 임계구역에 진입 전 잠금이 걸려 있는지 확인한다. (lock == true)
2. 만약 잠겨 있으면 잠금이 해제될 때까지 무한루프를 돌면서 기다린다.
3. 잠겨 있지 않으면 임계구역에 진입한 후 다른 프로세스가 진입하지 못하도록 잠금을 건다. (lock = true)
4. 작업을 마치면 다른 프로세스가 사용할 수 있도록 잠금을 해제한다. (lock = false)

<br>



위 코드는 다음과 같은 상황에 제대로 작동하지 않는다.

![동시 진입 상황](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2005%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EB%8F%99%EC%8B%9C%20%EC%A7%84%EC%9E%85%20%EC%83%81%ED%99%A9.png)

1. P1이 while문을 실행한다. 임계구역에 프로세스가 없기 때문에 무한 루프를 빠져나온다. 이어서 다음 문장을 실행하려고 하는 순간 주어진 CPU 시간을 다 써서(타임아웃) 준비 상태로 옮겨진다. 문맥 교환이 발생하고 P2가 실행 상태로 바뀐다.
2. P2는 while문을 실행한다. P1이 아직 잠금을 걸지 않았기 때문에 임계구역에 진입할 수 있다.
3. P1은 lock = true를 실행하여 임계구역에 잠금을 걸고 진입한다.
4. P2도 lock = true를 실행하여 임계구역에 잠금을 걸고 진입한다. 따라서 두 프로세스가 임계구역에 동시에 진입하게 된다.

따라서 해당 코드는 상호 배제 조건을 보장하지 못하며, 무한 루프로 인해 시스템 자원도 낭비된다.

<br>



### 한정 대기 문제

다음은 상호 배제를 보장하지 못하는 문제를 보완하여 작성한 코드이다.

![상호 배제 조건을 충족하는 코드](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2005%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%83%81%ED%98%B8%20%EB%B0%B0%EC%A0%9C%20%EC%A1%B0%EA%B1%B4%EC%9D%84%20%EC%B6%A9%EC%A1%B1%ED%95%98%EB%8A%94%20%EC%BD%94%EB%93%9C.png)

1. P1은 임계구역에 진입하기 전 먼저 잠금을 처리한다. (lock1 = true)
2. P1은 P2가 잠금을 설정했는지 확인한다. (while(lock2 == true))
3. 잠금을 설정하지 않은 경우 임계구역에 진입하여 작업을 마친 후 잠금을 해제한다. (lock1 = false)
4. P2 도 같은 방식으로 임계구역에 진입한다.

<br>



해당 방식은 두 개의 잠금을 사용하여 두 프로세스의 상호 배제가 보장된다. 그러나 다음과 같이 실행되는 경우 두 프로세스 모두 임계구역에 진입하지 못하는 무한 대기 현상이 발생할 수 있다.

1. P1이 lock1 = true를 실행한 후 CPU 시간을 다 써 문맥 교환이 발생하고 P2가 실행 상태로 바뀐다.
2. P2도 lock2 = true를 실행한 후 CPU 시간을 다 써 문맥 교환이 발생하고 P1이 실행 상태로 바뀐다.
3. P2가 lock2를 true로 바꿨기 떄문에 P1은 무한루프에 빠진다.
4. P1이 lock1를 true로 바꿨기 때문에 P2도 무한루프에 빠진다.

이와 같이 두 프로세스 모두 무한 루프에 빠져 살아있지만 작업이 진행되지 못하는 상태를 교착 상태(deadlock)라고 한다. 

또한 위와 같은 경우에는 프로세스가 늘어나면 lock의 개수도 같이 늘어나야 하기 때문에 확장성이 좋지 않다.

<br>



### 진행의 융통성 문제

![상호 배제와 한정 대기 조건을 충족하는 코드](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2005%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%83%81%ED%98%B8%20%EB%B0%B0%EC%A0%9C%EC%99%80%20%ED%95%9C%EC%A0%95%20%EB%8C%80%EA%B8%B0%20%EC%A1%B0%EA%B1%B4%EC%9D%84%20%EC%B6%A9%EC%A1%B1%ED%95%98%EB%8A%94%20%EC%BD%94%EB%93%9C.png)

해당 코드에서는 공유 변수의 값을 통해 프로세스가 임계구역에 있는지 확인하고 없으면 진입한다. 잠금을 확인하는 문장이 하나이기 때문에 상호 배제와 한정 대기를 보장한다. 그러나 서로 번갈아가면서 실행되기 때문에 한 프로세스가 두 번 연달아 임계구역에 진입할 수 없다. 이렇게 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 경직된 동기화라고 한다. 따라서 해당 코드는 진행의 융통성을 보장하지 못한다.

<br>



### 하드웨어적인 해결 방법

![검사와 지정을 이용한 코드](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2005%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EA%B2%80%EC%82%AC%EC%99%80%20%EC%A7%80%EC%A0%95%EC%9D%84%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%BD%94%EB%93%9C.jpg)

왼쪽 코드는 ①과 ② 문장이 분리되어 실행되면 두 명령어 중간에 타임아웃이 걸릴 수 있다. 두 명령어 중간에 타임아웃이 걸리는 경우 문제가 발생한다. 이 경우 하드웨어적으로 두 명령어를 동시에 실행하면 임계구역 문제를 쉽게 해결할 수 있다. 

왼쪽 코드의 1행과 2행은 오른쪽 코드의 1행과 같다. 이는 검사와 지정(test-and-set)이라는 코드로 하드웨어의 지원을 받아 두 문장을 한꺼번에 실행하여 타임아웃으로 인해 임계구역을 보호하지 못하는 문제를 예방한다.

임계구역을 하드웨어적으로 해결하는 방법은 편리하지만 바쁜 대기를 사용하여 검사하기 때문에 자원 낭비가 발생할 수 있다.

<br>



## 피터슨 알고리즘

임계구역 문제를 해결하기 위해 게리 피터슨이 제안한 방법으로 turn이라는 공유 변수를 더 사용한다.

![피터슨 알고리즘](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2005%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%ED%94%BC%ED%84%B0%EC%8A%A8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png)

1. P1은 임계구역에 진입하기 전 먼저 잠금을 한 후 turn을 2로 설정한다. 
   이때 변수 turn은 두 프로세스가 동시에 lock을 설정하여 임계구역에 못 들어가는 상황에 대비하기 위한 장치이다. 즉, 두 프로세스가 동시에 lock을 설정했더라고 turn을 사용하여 다른 프로세스에게 양보한다.
2. while을 실행한다. 만약 P2가 잠금을 설정하지 않았거나 잠금을 설정했더라도 곧바로 trun = 1로 바꾸면 P1은 임계구역에 진입하여 작업을 마친 후 잠금을 해제하고 임계구역을 빠져나온다. 
3. P2도 같은 방식으로 임계구역에 진입한다.

<br>



피터슨 알고리즘은 임계구역 해결의 세 가지 조건을 모두 만족하지만, 2개의 프로세스만 사용 가능하다는 한계가 있다.

<br>



## 데커 알고리즘

테오도뤼스 데커가 제안한 알고리즘으로 하드웨어의 도움 없이 임계구역 문제를 해결할 수 있다.

![데커 알고리즘](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2005%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EB%8D%B0%EC%BB%A4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png)

1. P1은 우선 잠금을 건다.
2. P2의 잠금이 걸렸는지 확인한다.
3. P2도 잠금을 걸었다면 turn을 이용하여 누가 먼저인지 확인한다. 만약 P1의 차례라면 임계구역으로 진입한다.
4. 만약 P2의 차례라면 P1은 잠금을 풀고 P2가 작업을 마칠 때까디 기다린다. P2가 작업을 마치면 잠금을 걸고 임계구역으로 진입한다.

<br>

 

피터슨 알고리즘과 데커 알고리즘은 임계 구역 해결의 세 가지 조건을 모주 만족하지만 매우 복잡하고 프로세스가 늘어나면 변수도 늘어난다. 임계구역 보호를 위해 복잡한 알고리즘을 구현하는 것은 바람직한 접근 방법이 아니다.

<br>



## 세마포어

에르허츠 데이크스트라가 제안한 알고리즘으로 앞의 알고리즘에 비해 간단하고 사용하기 쉽다. 

세마포어는 임계구역에 진입하기 전 스위치를 사용 중으로 놓고 임계구역에 들어간다. 이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다. 프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보낸다. 세마포어는 다른 알고리즘과 달리 임계구역이 잠겼는지 직점 점검하더나 바쁜 대기를 하거나 다른 프로세스에 동기화 메시지를 보낼 필요가 없다.

<br>



세마포어 코드

```c
Semaphore(n);
P();
/*
	임계구역
*/
V();

```

<br>

세마포어 내부 코드

```C
// Semaphore(n)
RS = n; 

// P()
if RS > 0 then RS = RS-1;
else block();

/*
	임계구역
*/

// V()
RS = RS + 1;
wake_up();
```

- Semaphore(n) : 전역변수 RS를 n으로 초기화한다. 이때 n은 공유 가능한 자원의 수이다.
- P() : 잠금을 수행하는 코드로 RS가 0보다 크면(사용 가능한 자원이 있음) 1만큼 감소시키고 임계구역에 진입한다. 만약 RS가 0이거나 0보다 작으면(사용 가능한 자원이 없음) 0보다 커질 때까지 기다린다. (block())

- V() : 잠금 해제와 동기화를 같이 수행하는 코드로 RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 wake_up 신호를 보낸다.

<br>



세마포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 wake_up 신호를 받으면 큐에서 나와 임계구역에 진입한다. 따라서 바쁜 대기를 하는 프로세스가 없다. 그러나 P()나 V() 내부 코드가 실행되는 도중에 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못한다. 그러므로 P()와 V()의 내부 코드는 검사와 지정을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 한다.

세마포어는 공유 자원이 여러 개일 떄도 사용할 수 있다.

<br>



## 모니터

세마포어의 잘못된 사용 예

- 프로세스가 세마포어를 사용하지 않고 바로 임계구역에 들어간 경우 임계구역을 보호할 수 없다.
- P()를 두 번 사용하여 wake_up 신호가 발생하지 않으면 프로세스 간의 동기화가 이루어지지 않아 세마포어 큐에서 대기하고 있는 프로세스들이 무한 대기에 빠진다.
- P()와 V()를 반대로 사용하면 상호 배제가 보장되지 않아 임계구역을 보호할 수 없다.

<br>



공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 굳이 P()와 V()를 사용할 필요 없이 자동으로 처리하면 된다. 이를 실제로 구현한 것이 모니터이다. 모니터는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시킨다.

모니터는 임계구역 보호와 동기화를 위해 내부적으로 상태 변수를 사용한다.

- wait() : 모니터 큐에서 자신의 차례가 올때까지 기다린다. 세마포어의 P()에 해당한다.
- signal() : 모니터 큐에서 기다리는 다음 프로세스에 숨서를 넘겨 준다. 세마포어의 V()에 해당한다.