# 스케줄링 알고리즘

스케줄링 알고리즘의 종류

| 구분              | 종류                                                         |
| ----------------- | ------------------------------------------------------------ |
| 비선점형 알고리즘 | FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링                    |
| 선점형 알고리즘   | 라운드 로빈 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 스케줄링 |
| 둘 다 가능        | 우선순위 스케줄링                                            |

<br>



## 스케줄링 알고리즘의 선택 기준

- CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법
- 처리량 : 단위 시간 당 작업을 마친 프로세스의 수로 수치가 클수록 좋음
- 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전따지 대기하는 시간으로 짧을수록 좋음
- 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간으로 짧을 수록 좋음
- 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원으로 모두 반환하는 데까지 걸리는 시간으로 대기 시간과 실행 시간을 더한 값

CPU 사용률과 처리량은 계산이 어렵기 때문에 주로 대기 시간, 응답 시간, 반환 시간을 계산한다.

<br>



대기 시간, 응답 시간, 실행 시간, 반환 시간의 관계

![대기시간, 응답시간, 실행시간, 반환시간의 관계](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2004%20CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EB%8C%80%EA%B8%B0%EC%8B%9C%EA%B0%84%2C%20%EC%9D%91%EB%8B%B5%EC%8B%9C%EA%B0%84%2C%20%EC%8B%A4%ED%96%89%EC%8B%9C%EA%B0%84%2C%20%EB%B0%98%ED%99%98%EC%8B%9C%EA%B0%84%EC%9D%98%20%EA%B4%80%EA%B3%84.png)

- 대기 시간 : 프로세스가 생성된 후 실행되기 전까지 대기하는 시간
- 응답 시간 : 첫 작업을 시작한 후 첫 번째 출력이 나오기까지의 시간
- 실행 시간 : 프로세스 작업이 시작된 후 종료되기까지의 시간
- 반환 시간 : 대기 시간을 포함하여 실행이 종료될 때까지의 시간

스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 본다. 평균 대기 시간은 모든 프로세스의 대기 시단을 합한 뒤 프로세스의 수로 나눈 값이다.

<br>



## FCFS 스케줄링

### FCFS 스케줄링의 동작 방식

FCFS(First Come First Served) 스케줄링은 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식으로 선입선출 스케줄링이라고도 한다. 초기의 일괄 작업 시스템에서 사용되었고, 모든 프로세스의 우선순위가 동일하다.

FCFS는 FIFO(First In First Out)라고도 하는데 일반적으로 FIFO는 큐를 가리키는 말이기 떄문에 이와 구분하기 위해 스케줄링 알고리즘에서는 FCFS라고 부른다. FIFO와 대응되는 FILO(First In Last Out)는 스택을 가리킨다.

<br>



### FCFS 스케줄링의 평가

FCFS 스케줄링 알고리즘은 단순하고 공평하지만, 처리 기간이 긴 프로세스가 CPU를 차지하면 다른 프로세스는 하염없이 기다리게 돼 시스템의 효율성이 떨어진다. 이를 콘보이 효과 또는 호위 효과라고 한다.

FCFS 스케줄링의 또 다른 단점은 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어진다는 것이다. 

<br>



## SJF 스케줄링

### SJF 스케줄링의 동작 방식

SJF(Shortest Job First) 스케줄링은 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식으로 최단 작업 우선 스케줄링이라고도 한다. 또는 SPF(Shortest Process First), 최단 프로세스 우선 스케줄링이라고도 한다.

SJF 스케줄링은 프로세스에 CPU를 배정할 때 시간이 오래 걸리는 작업이 앞에 있고 간단한 작업이 뒤에 있으면 그 순서를 바꾸어 실행한다. 따라서 콘보이 효과를완화할 수 있다.

<br>



### SJF 스케줄링의 평가

FCFS보다 평균 대기 시간이 줄어들어 시스템의 효율성이 높아지지만, 다음과 같은 이유로 사용하기 어렵다.

- 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.

- 공평하지 못하다. 

  작업 시간이 길다는 이유로 계속 뒤로 밀리는 경우 공평성이 떨어져 아사 현상 또는 무한 봉쇄 현상이 발생할 수 있다.



다음과 같은 해결 방안이 존재한다.

- 첫 번째 문제는 프로세스가 자신의 작업 시간을 운영체제에 알려주는 방식으로 해결할 수 있다. 하지만 프로세스가 자신의 작업 시간을 정확하게 알기 어렵고 일부 악의적인 프로세스가 작업 시간을 속이면 효율성이 저하된다.
- 두 번째 문제는 에이징으로 완화할 수 있다. 에이징은 프로세스가 양보할 수 있는 상한선을 정하는 것이다. 하지만 에이징 값을 정하는 기준도 확실하지 않아 한계가 있다.

<br>



## HRN 스케줄링

### HRN 스케줄링의 동작 방식

HRN(Highest Response Ratio Next) 스케줄링은 SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘으로 최고 응답률 우선 스케줄링이라고도 한다. 다음과 같은 계산을 통해 우선 순위를 결정한다.

![hrn 스케줄링](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2004%20CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/hrn%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81.png)

HRN 스케줄링은 우선순위를 정할 때 대기 시간으로 고려함으로써 아사 현상을 완화한다. 숫자가 클수록 우선순위가 높다.

<br>



### HRN 스케줄링의 평가

실행 시간이 짧은 프로세스의 우선순위를 높게 설정하고 대기 시간을 고려하여 아사 현상을 완화한다. 하지만 여전히 공평성이 위배되어 많이 사용되지 않는다.

<br>



## 라운드 로빈 스케줄링

### 라운드 로빈 스케줄링의 동작 방식

라운드 로빈 스케줄링은 순환 순서 방식이라고도 하며, 한 프로세스가 할당받은 시간 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식이다. 선점형 알고리즘 중 가장 단순하고 대표적인 방식으로 프로세스들이 작업을 완료할 때까지 계속 순환하며 실행된다.

우선순위가 적용되지 않은 가장 단순한 선점형 스케줄링 방식이다. 

<br>



### 타임 슬라이스의 크기와 문맥 교환

라운드 로빈 스케줄링과 FCFS 스케줄링의 평균 대기 시간이 같다면 라운드 로빈 스케줄링이 더 비효율적이다. 라운드 로빈은 선점형 방식이기 때문에 문맥 교환 시간이 추가되기 때문이다.

라운드 로빈 방식이 효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스를 적절히 설정해야 한다.

- 타임 슬라이스가 큰 경우 : 타임 슬라이스가 너무 크면 하나의 작업이 끝난 뒤 다음 작업이 실행되기 때문에 FCFS 스케줄링이 된다.
- 타임 슬라이스가 작은 경우 : 문맥 교환이 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 커지고 많은 시간을 낭비하게 된다. 따라서 실제 작업을 못 해 전반적인 성능이 떨어진다.

<br>



## SRT 우선 스케줄링

### SRT 스케줄링의 동작 방식

SRT(Shortest Remaining Time) 스케줄링은 SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식으로 최소 잔류 시간 우선 스케줄링이라고도 한다. SJF 스케줄링의 선점형 버전이라고 할 수 있다.

기본적으로 라운드 로빈 스케줄링을 사용하지만 CPU를 할당받을 프로세스를 선택할 때 남아있는 작업 시간이 가장 적은 프로세스를 선택한다. 

<br>



### SRT 스케줄링의평가

현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하기 때문에 해당 작업이 추가된다. 또한 운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않는다.

<br>



## 우선순위 스케줄링

### 우선순위 스케줄링의 동작 방식

우선순위 스케줄링은 어떤 기준으로 우선순위를 정하느냐에 따라 다양하게 구현할 수 있다.

우선순위는 비선점형 방식과 선점형 방식에 모두 사용할 수 있으며 두 가지로 나뉜다.

- 고정 우선순위 알고리즘 : 한 번 우선순위를 부여받으면 종료될 때까지 우선순위가 고정된다. 단순하게 구현할 수 있지만 시스템의 상황을 반영하지 못해 효율성이 떨어진다.
- 변동 우선순위 알고리즘 : 일정 시간마다 우선순위가 변한다. 따라서 시스템이 복잡하지만 시스템의 상황을 반영하여 효율적인 운영이 가능하다.

<br>



### 우선순위 스케줄링의 평가

우선순위 스케줄링은 준비 큐에 있는 프로세스 순서를 무시하고 우선순위에 따라 CPU를 할당하므로 공평성을 위배하고 아사 상태를 일으킨다. 또한 프로세스의 우선순위를 매번 바꿔야 하기 때문에 오버헤드가 발생하여 시스템의 효울성을 떨어트린다.

이러한 단점에도 불구하고 프로세스의 우선순위는 시스템의 효율성이 아니라 프로세스의 중요도에 따라 결정된다.

<br>



## 다단계 큐 스케줄링

다단계 큐 스케줄링은 우선순위에 따라 준비 큐를 여러 개 사용하는 방식이다. 라운드 로빈 방식으로 운영되는 큐는 우선순위에 따라 다단계로 나뉘어 있어 프로세스가 큐에 삽입되는 것만으로 우선순위가 결정된다. 우선순위는 고정형 우선순위를 사용하며 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다.

다단계 큐 스케줄링은 프로세스의 우선순위와 작업 형태를 고려하여 스케줄링할 수 있다.

<br>



## 다단계 피드백 큐 스케줄링

다단계 피드백 큐 스케줄링은 우선순위가 작은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보완한 방식이다. 다단계 피드백 큐 스케줄링의 경우 CPU를 사용하고 난 프로세스는 원래의 큐로 돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.

CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다. 단, 우선순위가 낮아진다고 해도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않는다.

또 다른 특징은 우선순위에 따라 타임 슬라이스의 크기가 다르다는 것이다. 프로세스의 우선순위가 낮아질수록 해당 큐의 타임 슬라이스를 크게 만들어 CPU를 조금 더 오래 사용할 수 있도록 한다. 따라서 우선순위가 가장 낮은 큐에 있는 프로세스는 무한대의 타임슬라이스를 얻어 FCFS 스케줄링 방식으로 동작한다.

다단계 피드백 큐 스케줄링은 오늘날 운영체제가 일반적으로 사용하는 방식으로 변동 우선순위 알고리즘의 전형적인 예이다.



