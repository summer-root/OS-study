# 프로세스의 개요

## 프로세스의 개념

프로그램은 저장장치에 저장되어 있는 정적인 상태이고, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다. 따라서 누군가가 작성한 프로그램이 실행되면 프로세스가 된다.

<br>



## 프로그램에서 프로세스로의 전환

프로세스는 컴퓨터 시스템의 단위로 태스크라고도 부른다. 시분할 방식 시스템에서 프로그램이 프로세스로 전환될 때 운영체제가 프로그램을 메모리의 적당한 위치로 가져온다. 그와 동시에 프로세스 제어 블록(PCB)을 만든다. 프로세스 제어 블록은 작업 지시서의 역할을 한다. 프로세스 제어 블록에는 프로세스를 처리하는 데 필요한 다양한 정보가 들어있고, 이 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못한다.

프로세스 제어 블록에 있는 정보 중 대표적 세 가지는 다음과 같다.

- 프로세스 구분자 : 메모리에는 여러 개의 프로세스가 존재하기 때문에 이를 구분하는 구분자가 필요하다.
- 메모리 관련 정보 : CPU는 실행하려는 프로세스가 메모리의 어디에 저장되어 있는지를 알아야 작업을 할 수 있다. 따라서 프로세스 제어 블록에는 프로세스 메모리의 위치 정보가 존재하고, 메모리 보호를 위한 경계 레지스터와 한계 레지스터도 포함되어 있다.
- 각종 중간값 : 프로세스 제어 블록에는 프로세스가 사용했던 중간값이 저장된다. 시분할 시스템에서는 여러 프로세스가 번갈아가며 실행되기 때문에 어디까지 작업을 했고, 다시 작업을 시작해야 할 위치를 알아야 한다. 따라서 프로세스 제어 블록에는 다음에 작업해야 할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장된다. 또한 작업의 중간 값을 보관 중인 다른 레지스터도 함께 저장된다.

프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다. 또한 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.

운영체제도 프로그램이기 때문에 프로세스 형태로 실행된다. 따라서 컴퓨터에서는 사용자 프로세스와 커널 프로세스가 섞여서 실행된다.

<br>



## 프로세스의 상태

일괄 작업 시스템의 경우 프로세스가 생성된 후 CPU를 얻어 실행되고 작업을 마치면 종료된다. 따라서 일괄 작업 시스템의 프로세스 상태는 생성, 실행, 완료이다. 하지만, 시분할 시스템의 경우 다른 프로세스에게 CPU를 넘겨주는 일이 빈번하기 떄문에 이보다 복잡하다.

<br>



### 프로세스의 네 가지 상태

- 생성 상태 (create status) : 프로세스가 메모리에 놀라와 실행 준비를 완료한 상태이다. 프로세스를 관리하는 데 필요한 프로세스 제어 블록이 생성된다.
- 준비 상태 (ready status) : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태이다. 
- 실행 상태 (running status) : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태로 execute status라고 표현하기도 한다. 실행 상태에 들어간 프로세스는 일정 시간 동안 CPU를 사용할 권리를 가진다. 만약 주어진 시간을 사용하고도 작업이 끝나지 않았다면 프로세스는 준비 상태로 돌아와 다음 차례를 기다린다. 프로세스는 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 왔다갔다 한다.
- 완료 상태 (terminate status) : 작업을 마친 프로세스는 완료 상태로 진입한다. 완료 상태는 프로세스 제어 블록이 사라진 상태를 의미한다.



준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케줄러가 담당한다. CPU 스케줄러는 준비 상태의 맨 앞에서 기다리고 있는 프로세스 제어 블록을 CPU에 전달하여 작업이 이루어지게 한다. 이를 디스패치라고 한다. CPU 스케줄러는 프로세스의 전 상태에 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 관리한다.

CPU 스케줄러에 의해 선택된 프로세스는 일정 시간 동안 작업을 하는데, 프로세스에 배당된 작업 시간을 타임 슬라이스 또는 타임 퀀텀이라고 부른다. 프로세스는 자신에게 주어진 하나의 타임 슬라이드 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아가는데 이를 타임아웃이라고 한다.

새로운 프로세스가 실행 상태로 들어오면 CPU는 타임 슬라이스 만큼의 시간이 흐른 뒤 알려 달라고 클록에게 요청한다. 해당 시간이 지나면 클록은 인터럽트를 사용하여 알려 준다.

<br>



### 프로세스의 다섯 가지 상태

운영체제의 효율성을 고려하여 만들어진 상태이다. 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태로 대기 상태(blocking status)라고 한다. 이는 CPU가 입출력을 기다리는 동안 아무것도 하지 않는 상황을 방지하기 위함이다. 대기 상태의 프로세스가 인터럽트를 받으면 실행 상태에서 옮겨왔기 떄문에 실행 상태로 옮겨 가는 것이 맞으나, 그러려면 현재 실행 중인 프로세스를 준비 상태로 돌려 보내야 한다. 두 프로세스의 상태를 변화시켜야 하는 복잡한 상황이므로 대기 상태에서 입출력이 끝난 프로세스는 준비 상태로 가 차례를 기다린다.

<br>



### 휴식 상태와 보류 상태

생성, 준비, 실행, 대기, 완료 상태의 경우 활성 상태이다. 휴식 상태와 보류 상태는 이와 다르게 특별한 경우이다.

- 휴식 상태 (pause status) : 프로세스가 작업을 일시적으로 쉬고 있는 상태이다. 유닉스에서는 ctrl+ z를 누르면 확인할 수 있다. 휴식 상태인 경우에는 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 멈춘 시점부터 재시작할 수 있다.

- 보류 상태 (suspend status) : 프로세스가 메모리에서 잠시 쫓겨난 상태이다. 일시 정지 상태라고도 불리며 다음의 경우에 보류 상태가 된다.

  - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 보낼 때
  - 프로그램에 오류가 있어 실행을 미루어야 할 때
  - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
  - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
  - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때

  보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관된다. 보류 상태는 대기 상태에서 옮겨진 보류 대기 상태와 준비 상태에서 옮겨진 보류 준비 상태로 구분되며, 각 상태에서 재시작하면 원래의 활성 상태로 들어간다. 또한 보류 대기 상태에서 입출력이 완료되면 활성 상태가 아닌 보류 준비 상태로 옮겨간다.

