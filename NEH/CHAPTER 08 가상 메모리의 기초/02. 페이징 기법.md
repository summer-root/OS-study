# 페이징 기법

## 페이징 기법의 구현

페이징 기법은 고정 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 주소 공간을 같은 크기도 나누어 사용한다. 

가상 주소의 분할된 각 영역은 페이지라고 부르며 첫 번째 영역은 페이지 0, 두 번째 영역은 페이지 1과 같이 번호를 매겨 관리한다. 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임이라고 부른다. 프레임도 페이지와 마찬가지로 번호를 매겨 관리하며, 페이지와 프레임의 크기는 같다.

<br>



페이지와 프레임은 크기가 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다. 페이지와 프레임의 매핑 정보는 페이지 테이블에 담겨 있다.

<br>



페이지 테이블은 하나의 열로 구성된다. 모든 페이지의 정보를 순서대로 가지고 있기 때문에 위에서부터 차례로 프레임 번호를 가지고 있어 추가 열이 필요 없다. 페이지 테이블에 있는 번호가 해당 페이지가 있는 프레임 번호를 나타내며, 물리 메모리에 없는 페이지는 invalid로 표시된다.

<br>



## 페이징 기법의 주소 변환

### 주소 변환 과정

![페이징 기법의 주소 변환](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2008%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98%20%EA%B8%B0%EC%B4%88/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%ED%8E%98%EC%9D%B4%EC%A7%95%20%EA%B8%B0%EB%B2%95%EC%9D%98%20%EC%A3%BC%EC%86%8C%20%EB%B3%80%ED%99%98.png)

<br>

가상 주소를 물리 주소로 변환하는 과정

1. 가상 주소가 어느 페이지에 있는지 찾는다.
2. 찾은 페이지의 페이지 테이블로 가서 해당 페이지가 어느 프레임에 있는지 알아낸다.
3. 최종적으로 찾은 물리 메모리 프레임의 위치에 접근한다.

<br>



프로세스가 가상 주소에 어떤 값을 저장하려고 할 때의 주소 변환 과정

1. 저장할 가상 주소 번지가 어느 페이지에 있는지 찾는다.
2. 찾은 페이지의 페이지 테이블로 가서 해당 페이지가 위치한 프레임을 알아낸다.
3. 프로세스가 저장하려는 값을 찾은 프레임 위치에 저장한다.

<br>



### 정형화된 주소 변환

페이징 기법에서의 가상 주소 표현 방식

```VA = <P, D>```

- VA : 가상 주소
- P : 페이지
- D : 페이지의 처음 위치에서 해당 주소까지의 거리 (오프셋이라고 정의하기도 함)

<br>

페이징 기법에서의 물리 주소 표현 방식

```PA = <F, D>```

- F : 프레임
- D : 프레임의 처음 위치에서 해당 주소까지의 거리

<br>



페이징 기법의 주소 변환 과정

가상 주소 VA = <P, D> → 물리 주소 PA = <F, D>

페이징 기법에서 주소 변환을 할 때 페이지 테이블을 사용하여 P는 F로 바꾸고 D는 변경 없이 그대로 쓴다. D를 변경하지 않는 이유는 페이지와 프레임의 크기를 똑같이 나누었기 때문이다. 

<br>

페이지 테이블은 페이지 번호, 프레임 번호로 구성되며 각각의 한 줄은 페이지 테이블 엔트리라고 부른다. 페이징 기법에서 페이지 테이블 엔트리는 프레임 번호만 가진다. 페이지 테이블에 페이지 번호가 0부터 순서대로 정리되어 있기 떄문에 페이지 번호를 표시할 필요가 없다. 페이지 테이블 엔트리가 페이지 번호, 프레임 번호로 구성된 것은 페이지 번호가 순서대로 저장되지 않은 경우이다.

<br>



### 16bit CPU의 주소 변환 예

컴퓨터는 2진법을 사용하므로 한 페이지의 크기는 2의 지수승으로 분할된다. 실제로 유닉스 계열의 운영체제인 VAX는 한 페이지의 크기가 2^9B이고, 윈도우 NT는 2^12B, 솔라리스는 2^13이다. 이렇게 페이지의 크기가 다양할 경우 가상 주소를 <P, D>로 변환하는 공식은 다음과 같다.

P = 가상 주소/한 페이지의 크기의 몫

D = 가상 주소/한 페이지의 크기의 나머지

<br>



16bit CPU의 컴퓨터에서 한 페이지의 크기가 2^10B일 때 페이징 시스템의 구성은 다음과 같다.

- 한 프로세스가 사용할 수 있는 가상 메모리의 크기 : 2^16B

- 사용할 수 있는 가상 주소 공간 : 0번지 ~ (2^16) -1번지

한 페이지의 크기가 2^10B이기 때문에 가상 주소로 사용할 수 있는 16bit 중 6bit는 페이지 번호로, 10bit는 페이지의 처음 위치에서 해당 주소까지의 거리로 사용한다.

<br>



실제 메모리가 최대가 아니더라도 부족한 물리 메모리는 스왑으로 처리할 수 있기 때문에 잘 작동한다.

<br>



## 페이지 테이블 관리

페이지 테이블 관리가 복잡한 이유는 시스템에 여러 개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문이다. 

페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요 시 빨리 접근할 수 있어야 한다. 따라서 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓는다.

시스템 내에는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다. 한 번에 실행하는 프로세스의 수가 많으면 페이지 테이블의 크기가 같이 커지고 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.

<br>

페이지 테이블 관리의 가장 큰 문제는 페이지 테이블의 크기가 작지 않다는 것이다. 최악의 경우 32bit CPU 시스템에서 페이지 테이블이 전체 4GB의 물리 메모리 중 1/4를 차지할 수도 있다. 따라서 페이지 테이블의 크기를 적정하게 유지하는 것이 페이지 테이블 관리의 핵심이다.

페이지 테이블의 수가 늘어나거나 페이지 테이블의 크기가 늘어나면 운영체제 영역이 늘어나 그만큼 사용자 영역이 줄어든다. 물리 메모리의 크기가 작을 때는 프로세스 뿐만 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.

<br>

각 프로세스가 메모리에 접근하려고 할 때 메모리 관리자는 페이지 테이블의 위치를 재빨리 파악하여야 하기 때문에 각 페이지 테이블의 시작 주소를 페이지 테이블 기준 레지스터에 보관한다. 페이지 테이블 기준 레지스터는 각 프로세스의 프로세스 제어 블록에 저장되는 데이터로 물리 메모리 내에 페이지 테이블의 시작 주소를 가지고 있다.

<br>



## 페이지 테이블 매핑 방식

페이지 테이블 전체를 메모리에서 관리하는지 일부를 스왑 영역에서관리하는지에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라진다.

### 직접 매핑

페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식이다. 별다른 부가 작업 없이 바로 주소 변환이 가능하다.

물리 메모리가 충분할 때 사용할 수 있으며 모든 페이지를 물리 메모리에 가지고 있기 때문에 주소 변환 속도가 빠르다.

![직접 매핑](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2008%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98%20%EA%B8%B0%EC%B4%88/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%A7%81%EC%A0%91%20%EB%A7%A4%ED%95%91.jpg)

직접 매핑에서 가상 주소를 물리 주소로 변환하려면 페이지 테이블의 P번째 위치(PTE P)에서 원하는 프레임 값을 얻을 수 있다. 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터(PTBR)가 가지고 있으므로 물리 메모리 상 페이지 테이블의 P번째 주소가 시작 주소로부터 P번째 위치에 존재한다.

<br>



### 연관 매핑

페이지 테이블 전체를 스왑 영역에서 관리하는 방식이다. 물리 메모리의 여유 공간이 작을 때 사용하는 방식으로, 모든 페이지 테이블을 저장장치의 스왑 영역에 저장하고 그중 일부만 물리 메모리에 가지고 있다. 

일부 내용만 무작위로 배치하기 때문에 페이지 번호와 프레임 번호 둘 다 표시한다. 따라서 페이지 테이블의 열은 직접 매핑이 1개, 연관 매핑이 2개이다.

주소 변환 시 물리 메모리 내의 페이지 테이블을 다 검색해야 한다. 만약 이렇게 했는데도 원하는 프레임 번호를 얻지 못하면 스왑 영역에 있는 페이지 테이블을 검색한다. 

<br>

물리 메모리에는 일부 페이지만 무작위로 저장되어 있고 그 일부분의 테이블을 변환 색인 버퍼 또는 연관 레지스터라고 부른다. 변환 색인 버퍼는 페이지 번호와 프레임 번호로 구성된 작은 크기의 테이블이다.

캐시 시스템과 작동 방식이 유사하다. 원하는 페이지를 먼저 변환 색인 버퍼에서 찾는데, 해당 버퍼에 있는 경우는 TLB 히트라고 하며 곧바로 물리 주소로 변환된다. 없는 경우 TLB 미스라고 하며 스왑 영역에 저장된 직접 매핑 테이블을 사용하여 프레임 번호로 변환한다. 

메모리를 절약할 수 있으나 TLB 미스가 빈번하게 발생하는 경우 시스템의 성능이 떨어진다.

<br>



### 집합-연관 매핑

멀티페이지 매핑이라고도 하며 연관 매핑의 문제를 개선한 방식이다. 무작위인 연관 매핑과 달리 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져온다.

페이지 테이블을 자르고 이를 관리하는 페이지 테이블을 하나 더 생성한다. 새로 생성한 집합 테이블에는 일정하게 자른 페이지 테이블이 물리 메모리에 있는지, 스왑 영역에 있는지에 대한 위치 정보를 표시한다. I로 표시된 경우 스왑 영역에 있다는 의미이다.

연관 매핑에서처럼 물리 메모리의 모든 페이지 테이블을 검사할 필요가 없어 주소 변환 시간이 단축된다.

<br>

집합-연관 매핑 방식에서는 페이지 테이블이 일정 크기의 묶음으로 나뉘기 때문에 가상 주소를 VA = <P, D>가 아니라 VA = <P1, P2, D>로 바꾸어 표시한다. P1은 디렉터리 테이블에서의 위치 정보를 의미하고, P2는 묶음 내에서의 위치 정보를 의미한다.

<br>



### 역매핑

앞의 세 가지 매핑과 반대로 페이지 테이블을 구성하는 방식이다. 물리 메모리의 프레임 번호를 기준으로 테이블을 구성한다. 역매핑에서는 테이블이 프레임을 기준으로 프로세스 아이디와 페이지 번호로 구성되며, 물리 메모리 상의 프레임 수와 테이블의 열 수가 같다.

역매핑의 가장 큰 특징은 프로세스의 수와 상관없이 테이블이 하나만 존재한다는 것이다. 따라서 테이블의 크기가 매우 작다. 하지만 프로세스가 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 한다. 따라서 속도가 아주 느리다.

<br>

역매핑 방식에서는 테이블이 <프레임 번호, 프로세스 아이디, 페이지 번호>로 구성되고, 페이지 테이블의 핼 수는 실제 프레임의 수와 같다. 그러므로 프로세스의 수와 상관없이 항상 일정 크기의 페이지 테이블을 유지하여 테이블의 크기가 매우 작다. 