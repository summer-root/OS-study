# 페이지 교체 알고리즘

## 페이지 교체 알고리즘의 개요

페이지 교체 알고리즘이란 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상한다.

<br>



### 페이지 교체 알고리즘의 종류

| 종류               | 알고리즘  | 특징                                                         |
| ------------------ | --------- | ------------------------------------------------------------ |
| 간단한 알고리즘    | 무작위    | 무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다.        |
|                    | FIFO      | 처음 메모리에 올라온 페이지를 스왑 영역으로 보낸다.          |
| 이론적 알고리즘    | 최적      | 미래의 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보낸다. |
| 최적 근접 알고리즘 | LRU       | 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.        |
|                    | LFU       | 사용 빈도가 적은 페이지를 스왑 영역으로 보낸다.              |
|                    | NUR       | 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다.       |
|                    | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높인다. (2차 기회 페이지 교체 알고리즘, 시계 알고리즘) |

최적 알고리즘의 경우 성능이 가장 좋지만 사실상 구현이 불가능하다.

<br>



### 페이지 교체 알고리즘의 성능 평가 기준

알고리즘 성능 비교에는 여러 가지 방법이 있다. 여기에서는 같은 메모리 접근 패턴을 사용하여 페이지 부재 횟수와 페이지 성공 횟수를 비교한다.

<br>



## 무작위 페이지 교체 알고리즘

페이지 교체 알고리즘 중 가장 간단하게 구현할 수 있는 방식이다. 대상 페이지를 특별한 로직 없이 무작위로 선정한다. 따라서 지역성을 고려하지 않기 때문에 성능이 좋지 않다.

<br>



## FIFO 페이지 교체 알고리즘

선입선출 페이지 교체 알고리즘이라고도 한다. 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 내보낸다.

![FIFO](사진 첨부/FIFO.png)

- F(Fail) : 페이지 부재가 일어난 경우
- S(Success) : 원하는 페이지가 메모리에 있는 경우

<br>



FIFO 페이지 교체 알고리즘은 큐로 구현한다. 메모리의 맨 위에 있는 페이지는 가장 오래된 페이지이고, 새로운 페이지는 맨 아래에 삽입된다. 메모리가 꽉 차면 맨 위에 있던 페이지가 스왑 영역으로 보내지고, 나머지 페이지들이 위쪽으로 이동하여 새로운 페이지가 아래쪽의 남는 공간에 들어온다.

FIFO 페이지 교체 알고리즘은 큐로 쉽게 구현할 수 있디만 메모리에 올라온 시간만 고려하기 때문에 자주 사용되는 페이지가 스왑 영역으로 옮겨지기도 한다. 이러한 이유로 성능이 떨어지는데 이 문제점을 개선한 것이 2차 기회 페이지 교체 알고리즘이다.

<br>



## 최적 페이지 교체 알고리즘

앞으로 사용하지 않을 페이지를 스왑 영역으로 옮기는 알고리즘이다. 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정한다.

![최적](사진 첨부/최적.png)

<br>



최적 페이지 교체 알고리즘은 미랴의 메모리 접근 패턴을 보고 대상 페이지를 결정하기 때문에 성능이 좋다. 하지만 미래의 접근 패턴을 아는 것이 불가능하기 때문에 실제로 구현할 수 없다.

최적 페이지 교체 알고리즘에 근접하는 방법을 연구하여 과거의 데이터를 바탕으로 미래의 접근 패턴을 추정하는 알고리즘을 개발하였는데, 이를 최적 근접 알고리즘이라고 한다. 최적 근접 알고리즘은 최적 페이지 교체 알고리즘과 유사한 성능을 보인다.

<br>



## LRU 페이지 교체 알고리즘

최근 최소 사용 페이지 교체 알고리즘이라고도 한다. 이 알고리즘은 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다. 

시간을 기준으로 구현할 수 있으며 카운터나 참조 비트를 이용하는 방법도 있다.

<br>



### 페이지 접근 시간에 기반한 구현

페이지에 읽기, 쓰기, 실행과 같은 연산이 이루어진 시간을 기준으로 접근한 지 가장 오래된 페이지를 교체한다.

![LRU](사진 첨부/LRU.png)

같은 메모리 접근 패턴에 대해 FIFO의 성공 횟수는 3이고 LRU의 성공 횟수는 4이다. 주의할 점은 메모리 접근 패턴을 변경하면 성능이 FIFO만큼 느려지기도 하고, 최적 페이지 교체 알고리즘만큼 좋아지기도 한다.

<br>



### 카운터에 기반한 구현

LRU는 접근 시간 대신 카운터를 사용하여 구현할 수도 있다.

접근 시간과 카운트 두 방법 모두 추가적인 메모리 공간을 필요로 하는 단점이 있다. 0~1024초를 표시하려면 10bit가 표시하고 그 이상인 경우 더 많은 비트를 사용해야 하기 때문에 사용자가 사용할 수 있는 공간이 낭비된다.

<br>



### 참조 시프트 방식

참조 시프트 방식은 각 페이지에 일정 크기의 참조 비트를 만들어 사용하는 것이다. 참조 비트의 초깃값은 0이며 페이지에 접근할 때마다 1로 바뀐다. 또한 참조 비트는 페이지에 접근할 때마다 오른쪽으로 한 칸씩 이동한다.

이렇게 참조 비트를 갱신하다가 대상 페이지를 선정할 필요가 있는 경우 참조 비트 중 가장 작은 값을 대상 페이지로 선정한다.

![참조 비트 시프트](사진 첨부/참조 비트 시프트.png)

<br>



참조 비트 시프트 방식은 LFU 페이지 교체 알고리즘과 혼동되기도 한다. 그러나 참조 비트 중에 가장 큰 값이 되려면 접근 횟수와 상관없이 제일 최근에 접근한 페이지가 제일 큰 값이 되기 때문에 참조 비트 시프트 방식은 LRU 방식이다.

참조 비트 시프트 방식도 1B이기는 하지만 공간을 사용하기 때문에 공간이 낭비된다. 이렇듯 LRU 페이지 교체 알고리즘의 단점은 낭비되는 메모리 공간이 있다는 것이다.