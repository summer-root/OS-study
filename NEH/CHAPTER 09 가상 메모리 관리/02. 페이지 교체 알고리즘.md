# 페이지 교체 알고리즘

## 페이지 교체 알고리즘의 개요

페이지 교체 알고리즘이란 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상한다.

<br>



### 페이지 교체 알고리즘의 종류

| 종류               | 알고리즘  | 특징                                                         |
| ------------------ | --------- | ------------------------------------------------------------ |
| 간단한 알고리즘    | 무작위    | 무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다.        |
|                    | FIFO      | 처음 메모리에 올라온 페이지를 스왑 영역으로 보낸다.          |
| 이론적 알고리즘    | 최적      | 미래의 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보낸다. |
| 최적 근접 알고리즘 | LRU       | 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.        |
|                    | LFU       | 사용 빈도가 적은 페이지를 스왑 영역으로 보낸다.              |
|                    | NUR       | 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다.       |
|                    | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높인다. (2차 기회 페이지 교체 알고리즘, 시계 알고리즘) |

최적 알고리즘의 경우 성능이 가장 좋지만 사실상 구현이 불가능하다.

<br>



### 페이지 교체 알고리즘의 성능 평가 기준

알고리즘 성능 비교에는 여러 가지 방법이 있다. 여기에서는 같은 메모리 접근 패턴을 사용하여 페이지 부재 횟수와 페이지 성공 횟수를 비교한다.

<br>



## 무작위 페이지 교체 알고리즘

페이지 교체 알고리즘 중 가장 간단하게 구현할 수 있는 방식이다. 대상 페이지를 특별한 로직 없이 무작위로 선정한다. 따라서 지역성을 고려하지 않기 때문에 성능이 좋지 않다.

<br>



## FIFO 페이지 교체 알고리즘

선입선출 페이지 교체 알고리즘이라고도 한다. 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 내보낸다.

![FIFO](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/FIFO.png)

- F(Fail) : 페이지 부재가 일어난 경우
- S(Success) : 원하는 페이지가 메모리에 있는 경우

<br>



FIFO 페이지 교체 알고리즘은 큐로 구현한다. 메모리의 맨 위에 있는 페이지는 가장 오래된 페이지이고, 새로운 페이지는 맨 아래에 삽입된다. 메모리가 꽉 차면 맨 위에 있던 페이지가 스왑 영역으로 보내지고, 나머지 페이지들이 위쪽으로 이동하여 새로운 페이지가 아래쪽의 남는 공간에 들어온다.

FIFO 페이지 교체 알고리즘은 큐로 쉽게 구현할 수 있디만 메모리에 올라온 시간만 고려하기 때문에 자주 사용되는 페이지가 스왑 영역으로 옮겨지기도 한다. 이러한 이유로 성능이 떨어지는데 이 문제점을 개선한 것이 2차 기회 페이지 교체 알고리즘이다.

<br>



## 최적 페이지 교체 알고리즘

앞으로 사용하지 않을 페이지를 스왑 영역으로 옮기는 알고리즘이다. 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정한다.

![최적](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%B5%9C%EC%A0%81.png)

<br>



최적 페이지 교체 알고리즘은 미랴의 메모리 접근 패턴을 보고 대상 페이지를 결정하기 때문에 성능이 좋다. 하지만 미래의 접근 패턴을 아는 것이 불가능하기 때문에 실제로 구현할 수 없다.

최적 페이지 교체 알고리즘에 근접하는 방법을 연구하여 과거의 데이터를 바탕으로 미래의 접근 패턴을 추정하는 알고리즘을 개발하였는데, 이를 최적 근접 알고리즘이라고 한다. 최적 근접 알고리즘은 최적 페이지 교체 알고리즘과 유사한 성능을 보인다.

<br>



## LRU 페이지 교체 알고리즘

최근 최소 사용 페이지 교체 알고리즘이라고도 한다. 이 알고리즘은 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다. 

시간을 기준으로 구현할 수 있으며 카운터나 참조 비트를 이용하는 방법도 있다.

<br>



### 페이지 접근 시간에 기반한 구현

페이지에 읽기, 쓰기, 실행과 같은 연산이 이루어진 시간을 기준으로 접근한 지 가장 오래된 페이지를 교체한다.

![LRU](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/LRU.png)

같은 메모리 접근 패턴에 대해 FIFO의 성공 횟수는 3이고 LRU의 성공 횟수는 4이다. 주의할 점은 메모리 접근 패턴을 변경하면 성능이 FIFO만큼 느려지기도 하고, 최적 페이지 교체 알고리즘만큼 좋아지기도 한다.

<br>



### 카운터에 기반한 구현

LRU는 접근 시간 대신 카운터를 사용하여 구현할 수도 있다.

접근 시간과 카운트 두 방법 모두 추가적인 메모리 공간을 필요로 하는 단점이 있다. 0~1024초를 표시하려면 10bit가 표시하고 그 이상인 경우 더 많은 비트를 사용해야 하기 때문에 사용자가 사용할 수 있는 공간이 낭비된다.

<br>



### 참조 시프트 방식

참조 시프트 방식은 각 페이지에 일정 크기의 참조 비트를 만들어 사용하는 것이다. 참조 비트의 초깃값은 0이며 페이지에 접근할 때마다 1로 바뀐다. 또한 참조 비트는 페이지에 접근할 때마다 오른쪽으로 한 칸씩 이동한다.

이렇게 참조 비트를 갱신하다가 대상 페이지를 선정할 필요가 있는 경우 참조 비트 중 가장 작은 값을 대상 페이지로 선정한다.

![참조 비트 시프트](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%B0%B8%EC%A1%B0%20%EB%B9%84%ED%8A%B8%20%EC%8B%9C%ED%94%84%ED%8A%B8.png)

<br>



참조 비트 시프트 방식은 LFU 페이지 교체 알고리즘과 혼동되기도 한다. 그러나 참조 비트 중에 가장 큰 값이 되려면 접근 횟수와 상관없이 제일 최근에 접근한 페이지가 제일 큰 값이 되기 때문에 참조 비트 시프트 방식은 LRU 방식이다.

참조 비트 시프트 방식도 1B이기는 하지만 공간을 사용하기 때문에 공간이 낭비된다. 이렇듯 LRU 페이지 교체 알고리즘의 단점은 낭비되는 메모리 공간이 있다는 것이다.

<br>



## LFU 페이지 알고리즘

최소 빈도 사용 알고리즘이라고도 하며 페이지가 몇 번 사용되었는지를 기준으로 대상 페이지를 선정한다. 사용된 횟수가 가장 적은 페이지가 대상 페이지가 된다. 

<br>



![LFU](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/LFU.png)

처음 메모리에 올러온 페이지의 사용 빈도는 1이고 페이지가 사용될 때마다 1씩 증가한다. 

같은 메모리 패턴에 대해 LFU가 LRU보다 한 번 더 성공했지만 일반적인 경우 두 알고리즘의 성능은 비슷하다고 알려져 있다. 두 알고리즘은 모두 FIFO보다 성능이 우수하다.

LFU 페이지 알고리즘의 단점은 페이지 접근 횟수를 표시하는 데 추가 공간이 필요하므로 그만큼의 메모리가 낭비된다는 것이다.

<br>



## NUR 페이지 교체 알고리즘

LRU, LFU 페이지 교체 알고리즘과 성능이 거의 비슷하면서 불필요한 공간 낭비 문제를 해결한 알고리즘이다. 최근 미사용 페이지 교체 알고리즘이라고도 불린다.

<br>



접근 시간 또는 접근 빈도에 대한 정확한 값을 유지하는 것은 공간만 많이 차지할 뿐 의미가 없다. NUR은 이러한 경향을 반영한 방식으로 추가 비트 2개만을 사용하여 미래를 추정한다.

NUR에서는 페이지마다 참조 비트와 변경 비트를 가진다. 참조 비트는 PTE의 접근 비트를 가리키고, 변경 비트는 PTE의 변경 비트를 가리킨다. 둘 다 초기값은 0이며, 다음의 경우 1이 된다.

- 참조 비트 : 페이지에 접근하는 경우 (read/execute)
- 변경 비트 : 페이지가 변경되는 경우 (write/append)

<br>



NUR의 대상 페이지 선정 순서는 다음과 같다.

| 참조 비트 | 변경 비트 |
| --------- | --------- |
| 0         | 0         |
| 0         | 1         |
| 1         | 0         |
| 1         | 1         |

모든 페이지가 (1,1)인 경우 어떤 페이지가 더 자주 사용되는지 알 수 없기 때문에 모든 페이지 비트가 초기화된다.

<br>



![NUR](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/NUR.png)

<br>



최적 근접 알고리즘의 성능은 거의 비슷하며 FIFO 페이지 교체 알고리즘보다 우수하다. 이 중 NUR 페이지 교체 알고리즘은 2bit만 추가하여 다른 알고리즘과 유사한 성능을 내고 쉽게 구현할 수 있어 가장 많이 사용된다.

<br>



## FIFO 변형 알고리즘

FIFO 페이지 교체 알고리즘의 방식을 기본으로 하나, 페이지에 접근할 때마다 순서의 변화를 주어 성능을 향상한다.

<br>



### 2차 기회 페이지 교체 알고리즘

2차 기회 FIFO 페이지 교체 알고리즘이라고도 한다.

FIFO와 마찬가지로 큐를 사용하지만 차이점은 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우 해당 페이지를 큐의 맨 뒤로 이동하여 대상 페이지에서 제외한다는 것이다. 

![2차 기회](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/2%EC%B0%A8%20%EA%B8%B0%ED%9A%8C.png)

<br>

일반적으로 2차 기회 페이지 교체 알고리즘의 성능은 최적 근접 알고리즘보다 약간 낮고 FIFO보다 약간 높다. 그러나 큐를 유지하는 비용이 높고 페이지가 성공하면 큐의 중간에 있는 값을 뒤로 이동하는 작업이 추가되는 것이 단점이다.

<br>



### 시계 알고리즘

2차 기회 페이지 교체 알고리즘과 유사하나 구현 방법은 상이하다. 2차 기회 페이지 교체 알고리즘은 큐를 사용하지만, 시계 알고리즘은 원형 큐를 사용한다.

시계 알고리즘에서는 대상 페이지를 가리키는 포인터를 사용하는데, 이 포인터가 큐의 맨 바닥으로 내려가면 다음번에는 다시 큐의 처음을 가리키게 된다. 

<br>



![시계](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%8B%9C%EA%B3%84.png)

동작 순서는 다음과 같다.

1. 포인터는 처음 메모리에 올라온 페이지를 가리킨다
2. 메모리가 꽉 차면 포인터가 가리키는 페이지가 스왑 영역으로 이동한다.
3. 스왑 영역으로 이동하면 포인터는 한 칸 아래로 이동한다.
4. 페이지가 참조되는 경우 참조 비트가 1이 되고, 참조 비트가 1인 페이지는 포인터가 건너뛴다. 이때 참조 비트는 다시 0으로 변경된다.

<br>



시계 알고리즘은 대상 포인터와 참조 비트 하나만 추가하면 되기 때문에 NUR보다 추가 공간이 적게 들지만, 알고리즘이 복잡하고 계산량이 많다.