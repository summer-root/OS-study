# 스레싱과 프레임 할당

## 스레싱

### 스레싱의개념

스레싱 : 하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태

<br>



### 물리 메모리의 크기와 스레싱

스레싱은 메모리의 크기가 일정할 경우 멀티프로그램의 수와 밀접한 관계가 있다. 동시에 실행하는 프로그램의 수를 멀티프로그래밍 정도라고 하는데 멀티프로그래밍 정도가 너무 높으면 스레싱이 발생한다.

프로그램의 수가 적을 때 CPU를 사용하면 CPU 사용률이 계속 증가하다가 메모리가 꽉 차면 CPU가 작업하는 시간보다 스왑 영역으로 페이지를 보내고 새로운 페이지를 메모리에 가져오는 작업에 소요되는 시간이 많아져서 CPU가 작업할 수 없는 상태에 이른다. 이 시점을 스레싱 발생 지점이라고 한다.

따라서 물리 메모리의 용량을 늘리면 스레싱 발생 지점이 늦춰지기 때문에 컴퓨터의 성능이 향상된다. 하지만 물리 메모리가 작업을 하는 데 충분한 크기가 되면 그 이후에는 크기를 늘려도 작업 속도에 영향을 미치지 않는다.

<br>



### 스레싱과 프레임 할당

스레싱은 각 프로세스에 프레임을 할당하는 문제와도 연관된다. 실행 중인 여러 프로세스에 프레임을 얼마나 나누어주느냐에 따라 시스템의 성능이 달라진다. 프로세스에 프레임을 할당하는 방식은 크게 정적 할당과 동적 할당으로 구분된다.

<br>



## 정적 할당

프로세스 실행 초기에 프레임을 나누어준 후 그 크기를 고정하는 방식으로 균등 할당 방식과 비례 할당 방식이 있다.

<br>



### 균등 할당

프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당한다. 균등 할당 방식에서는 크기가 큰 프로세스의 경우 필요한 만큼 프레임을 할당받지 못하기 때문에 페이지 부재가 빈번하게 발생하고, 크기가 작은 프로세스의 경우 메모리가 낭비된다.

<br>



### 비례 할당

프로세스의 크기에 비례하여 프레임을 할당하는 방식이다. 비례 할당은 고정 할당보다 좀 더 현실적인 방식이다. 그러나 다음과 같은 두 가지 문제가 있다.

- 프로세스가 실행 중 필요로 하는 프레임을 유동적으로 반영하지 못한다. 작은 프로세스도 실행 중 많은 메모리(프레임)을 필요로 하는 경우가 있는데, 이를 유동적으로 반영하지 못한다. (ex. 동영상 플레이어)
- 사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비한다. 요구 페이징 방식에서는 아무리 큰 프로세스라고 하더라도 처음부터 메모리에 모두 올리지 않는데, 비례 할당 방식에서는 큰 프로세스를 실행하면서 당장 필요 없는 프레임을 미리 할당해 놓기 때문에 메모리가 낭비된다.

<br>



## 동적 할당

정적 할당 방식은 프로세스 실행 초기에 프레임을 할당하기 때문에 프로세스를 실행하는 동안 메모리 요구를 반영하지 못하는 단점이 있다. 이와 반대로 변하는 요청을 수용하는 방식이 동적 할당이다. 동적 할당에는 작업집합 모델을 사용하는 방식과 페이지 부재 빈도를 사용하는 방식이 있다.

<br>



### 작업집합 모델

지역성 이론을 바탕으로 하며, 가장 최근에 접근한 프레임이 이후에도 또 참조될 가능성이 높다는 가정에서 출발한다. 최든 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지하여 프로세스의 실행을 돕는다.

작업 집합 모델에서 물리 메모리에 유지할 페이지의 크기를 작업집합 크기라고 하고, 이는 작업집합에 들어갈 최대 페이지 수를 의미한다. 작업집합에 포함되는 페이지의 범위를 윈도우라고 한다. 현재 시점에 최대 어느 범위까지의 페이지를 살펴볼 것인가를 결정하는 것이 작업집합 윈도우이다.

<br>



![작업집합 모델](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%9E%91%EC%97%85%EC%A7%91%ED%95%A9%20%EB%AA%A8%EB%8D%B8.png)



작업집합 윈도우에서는 현재 시점부터 시간적으로 가까운 페이지부터 삽입된다.

작업집합 크기는 작업집합에 들어갈 최대 페이지 수를 말하지만 얼마나 자주 작업집합을 갱신할 것인지도 의미한다. 작업집합 크기가 5라는 것은 페이지에 다섯 번 접근할 때마다 작업집합을 갱신한다는 의미이다. 

<br>



프로세스가 진행되며 작업집합이 변하는 과정은 다음과 같다.

![시간에 따른 작업집합의 변화](https://github.com/summer-root/OS-study/blob/main/NEH/CHAPTER%2009%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%82%AC%EC%A7%84%20%EC%B2%A8%EB%B6%80/%EC%8B%9C%EA%B0%84%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EC%9E%91%EC%97%85%EC%A7%91%ED%95%A9%EC%9D%98%20%EB%B3%80%ED%99%94.png)

<br>



작업집합 모델에서는 작업집합 윈도우의 크기에 따라 프로세스의 실행 성능이 달라진다. 작업집합 윈도우를 너무 크게 잡으면 필요 없는 페이지가 메모리에 남아서 다른 프로세스에 영향을 미친다. 반대로 윈도우를 너무 작게 잡으면 필요한 페이지가 스왑 영역으로 이동되어 성능이 떨어진다.

<br>



### 페이지 부재 빈도

작업집합 모델의 경우 충분한 페이지를 할당하지 않으면 작업집합에 있는 페이지를 물리 메모리에 유지하기 힘들다. 작업집합 모델에서는 어떤 프레임을 물리 메모리에 유지해야 하는지 알 수 있지만 프로세스에 프레임을 얼마나 할당해야 하는지 알 수 없기 때문에 프로세스의 성능은 높아지지만 스레싱 문제를 해결하지는 못한다.

페이지 부재 빈도를 이용하는 방식은 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식이다. 해당 방식에서는 페이지 부재 비율의 상한선과 하한선을 설정한다. 상한선을 초과하는 경우 할당한 프레임이 적은 것이기 때문에 프레임을 추가하고 하한선 밑으로 내려가는 경우 메모리가 낭비된다는 의미이므로 할당한 프레임을 회수한다.

프로세스가 처음 시작될 때는 할당량 예측이 어렵지만 프로세스를 실행하면서 추가적으로 할당, 회수하여 적정 페이지 할당량을 조절한다.