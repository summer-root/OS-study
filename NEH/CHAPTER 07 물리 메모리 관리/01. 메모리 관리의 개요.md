# 메모리 관리의 개요

여기에서 관리하는 메모리는 메인 메모리를 가리킨다.

<br>



## 메모리 관리의 복잡성

메모리의 구조는 1B 크기로 나뉜다. 1B로 나뉜 각 영역은 메모리 주소로 구분하는데 보통 0번지부터 시작한다. CPU는 메모리에 있는 내용을 가져오거나 작업 경과를 메모리에 저장하기 위해 메모리 주소 레지스터를 사용한다. 메모리 주소 레지스터에 필요한 메모리 주소를 넣으면 데이터를 메모리 에서 가져오거나 메모리에 데이터를 옮길 수 있다.

복잡한 메모리 관리는 메모리 관리 시스템이 담당한다.

<br>



## 메모리 관리의 이중성

메모리 관리의 이중성이란 프로세스 입장에서는 메모리를 독차지하려고 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것을 말한다. 즉 프로세스 입장에서 작업의 편리함과 관리자 입장에서 관리의 편리함이 충돌을 일으키는 것이다.

<br>



:pencil2: 프로그램을 메모리에서 실행하는 이유

메모리를 계층적 구조로 만들어 작업 속도를 올리고 가격을 낮추는 계층적 메모리 구조를 사용하기 때문이다. 속도가 빠른 캐시는 빠르고 비싸지만 속도가 느린 제2저장장치는 가격리 저렴하다. 메모리 관리의 복잡성은 크지 않은 메모리에서 여러 작업을 동시에 실행하는 문제에서 비롯되었다. 

<br>



## 소스코드의 번역과 실행

### 컴파일러와 인터프리터의 동작

- 컴파일러 : 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행한다. C언어, 자바 등이 이 방식으로 프로그램을 실행한다.
- 인터프리터 : 소스코드를 한 행씩 번역하여 실행한다. 자바스크립트, 베이직 등이 이 방식으로 프로그램을 실행한다.

<br>



### 컴파일러의 목적

- 오류 발견 : 컴파일러는 오류를 찾기 위해 심벌 테이블을 사용한다. 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 타입을 모아 놓은 테이블로 선언하지 않은 변수를 사용하지 않았는지, 변수에 다른 타입의 데이터를 저장하지 않았는지 알 수 있다.
- 코드 최적화 : 간결하고 속도가 빨라지도록 한다.

<br>



:pencil2: 컴파일된 파일의 확장자

윈도우에서 실행 가능한 프로그램의 확장자는 exe 또는  com이므로 컴파일러가 번역한 기계어 코드의 확장자가 exe나 com이다. 유닉스의 경우 실행 가능 여부를 나타내는 특별한 확장자가 없다. 유닉스에서 옵션 없이 컴파일된 파일은 a.out이다.

<br>



### 컴파일러와 인터프리터의 차이

컴파일러를 사용하는 프로그래밍 언어는 사용할 변수를 미리 선언한 후 코드를 작성한다. 인터프리터 방식의 언어는 변수를 미리 선언할 필요가 없다.

크고 복잡한 프로그램에는 컴파일러를 사용하고 간단한 프로그램에는 인터프리터를 사용한다.

<br>



### 컴파일 과정

컴파일은 사용자가 작성한소스코드를 목적 코드로 변환한 후 라이브러리를 연결하고 최종 실행 파일을 만들어 실행하는 과정이다.

소스코드 → 컴파일러 → 목적 코드 → 링커 → 실행

1. 소스코드 작성 및 컴파일 : 소스코드를 컴파일러로 일차로 번역하여 목적 코드가 만들어진다.
2. 목적 코드와 라이브러리 연결 : 목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.
3. 동적 라이브러리를 포함하여 최종 실행 : 과거에는 새로운 기능이 추가되면 해당 기능이 담긴 라이브러리를 가져와 다시 컴파일해야 했다. 하지만 새로운 기능이 생길 때마다 다시 컴파일하는 것은 번거로운 일이기 때문에 최근에는 해당 부분의 자리를 비워 놓고 컴파일한 후, 실행할 때 실행 코드를 라이브러리에서 가져와 실행하는 방법을 사용한다. 이렇게 실행할 때 삽입되는 함수를 가진 라이브러리를 동적 라이브러리라고 한다. 
   윈도우에서는 동적 라이브러리 파일을 DLL이라고 부른다. 윈도우에서 함수의 변경이 일어난 경우 해당 DLL 파일을 수해 특정 폴더에 삽입하면 새로운 기능을 구현할 수 있다.

<br>



## 메모리 관리자의 역할

메모리 관리자는 정확히 말해 메모리 관리 유닛이라는 하드웨어이다. 메모리 관리자의 작업은 가져오기, 배치, 재배치이다.

- 가져오기 작업 : 프로세스와 데이터를 메모리로 가져오는 작업이다. 사용자 요청 시 프로세스와 데이터를 모두 메모리에 가져온다. 하지만 용량이 커서 가지고 올 수 없는 등 특수한 경우에는 데이터의 일부만 가져와 실행하기도 한다. 사용자의 요청이 없더라도 앞으로 필요할 것으로 예상되는 데이터를 미리 가져오기도 한다.
- 배치 작업 : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 놓을지 결정하는 작업이다. 배치 작업 전 메모리를 어떤 크기로 자를것인지가 매우 중요하다. 같은 크기로 자를지, 실행되는 프로세스의 크기에 맞게 자를지에 따라 메모리 관리의 복잡성이 달라진다.
- 재배치 작업 : 새로운 프로세스를 가져와야 하는데 메모리가 꽉 찬 경우에 오래된 프로세스를 내보내는 작업을 말한다.

<br>



메모리 관리자는 가져오기, 배치, 재배치 작업 시 다음과 같은 정책을 수립하여 그 정책에 따라 메모리를 관리한다.

- 가져오기 정책 : 프로세스가 필요로 하는 데이터를 메모리에 언제 가져올지 결정하는 정책이다. 프로세스 요청 시 가져오는 것이 일반적이나 필요가 예상되는 데이터를 미리 가져오는 방법도 있다.
- 배치 정책 : 메모리를 같은 크기로 자르는 것을 페이징이라고 하며, 프로세스 크기에 맞게 자르는 것을 세크먼테이션이라고 한다. 배치 정책은 둘의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있도록 정책을 만드는 것이다. 시스템의 효율을 좌우한다.
- 재배치 정책 : 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책이다. 앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘을 교체 알고리즘이라고 한다