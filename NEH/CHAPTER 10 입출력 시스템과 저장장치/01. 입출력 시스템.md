# 입출력 시스템

## 입출력 장치와 채널

컴퓨터의 주변장치는 데이터 전송 속도에 따라 저속주변 장치와 고속 주변장치로 구분할 수 있다.

- 저속 주변장치 : 메모리와 주변장치 사이에 오고 가는 데이터의 양이 적어 데이터 전송률이 낮은 장치를 말한다. 대표적으로 키보드가 있다.
- 고속 주변장치 : 메모리와 주변장치 사이에 대용량의 데이터가 오고 가므로 데이터 전송률이 높은 장치를 말한다. 대툐적으로 그래픽카드, 하드디스크가 있다.

<br>



여러 주변장치는 메인보드 내의 버스로 연결된다. 그런데 버스에는 많은 종류의 장치가 연결되기 때문에 버스를 1개만 사용하면 병목 현상이 발생한다. 따라서 여러 개의 버스를 묶어서 사용하는데, 이때 데이터가 지나다니는 하나의 통로를 채널이라고 부른다.

- 채널 공유 : 채널을 모든 주변장치가 공유하는 것으로 전체적으로 데이터 전송 속도가 느려진다.
- 채널 분리 : 속도가 비슷한 장치끼리 묶어 채널을 할당하는 것으로 전체 데이터 전송 속도를 향상할 수 있다.

<br>



## 입출력 버스의 구조

### 초기의 구조

컴퓨터 사용 초기에는 모든 장치가 하나의 버스로 연결되고, CPU가 작업을 진행하다가 입출력 명령을 만나면 직접 입출력장치에서 데이터를 가져왔는데 이를 폴링 방식이라고 한다.

폴링 방식은 전체 작업 효율이 떨어진다.

<br>



### 입출력 제어기를 사용한 구조

주변장치가 많아짐에 따라 CPU가 모두 관리하기 어려워져 입출력 제어기에게 모든 입출력을 맡기는 구조로 변경되었다.

입출력 제어기는 메인버스와 입출력 버스로 나뉘며, 메인버스는 고속으로 작동하는 CPU와 메모리가 사용하고 입출력 버스는 주변장치가 사용한다. CPU에서 입출력 요청이 오면 입출력 제어기는 입출력장치로부터 데이터를 직접 송수신한다. 입출력 제어기를 사용하면 느린 입출력장치로 인해 CPU와 메모리의 작업이 느려지는 것을 막을 수 있다.

<br>



### 입출력 버스의 분리

저속 주변장치와 고속 주변장치가 입출력 버스를 공유하면 입출력 속도가 저하된다. 이를 해결하기 위해 입출력 버스를 저속, 고속으로 분리하여 사용한다. 두 버스 사이의 데이터 전송은 채널 선택기가 관리한다. 예를 들어 고속 입출력 버스에서 10번 데이터를 받으면 저속 입출력 버스에서 1번 데이터를 받는 방식으로 데이터 전송 속도를 조절한다.

<br>

그래픽카드의 경우 3D 게임이 보급되며 계산하는 양이 늘어남에 따라 GPU를 부착하게 되었다. GPU의 계산 능력은 CPU를 능가하며 다루는 데이터 또한 고속 입출력 버스로 감당할 수 없을 만큼 대용향이다. 따라서 크래픽카드는 입출력 버스에서 분리하고 메인버스에 바로 연결해 사용하게 되었다. 그래픽카드는 그래픽 전용 포트인 AGP에 꽂아 사용한다.

<br>



## 직접 메모리 접근

CPU의 도움 없이도 메모리에 접근할 수 있도록 입출력 제어기에 부여된 권한으로 입출력 제어기에는 직접 메모리에 접근하기 위한 DMA 제어기가 마련되어 있다.

CPU의 작업 공간과 DMA의 작업 공간이 겹치는 것을 방지하기 위해 과거에는 DMA 제어기가 전송하는 데이터를 입출력 메모리라는 별도의 메모리에 보관했다. 그러나 이 방식은 입출력 메모리에서 다시 메인 메모리로 데이터를 옮기는 불필요한 작업을 수반한다. 오늘날의 입출력 시스템에서는 CPU가 작업하는 공간과 DMA 제어기가 데이터를 옮기는 공간을 분리하여 메인메모리를 운영한다. 이를 메모리 맵 입출력이라고 부른다. 

<br>



## 인터럽트

### 입출력과 인터럽트

입출력 제어기와 DMA 제어기의 협업으로 작업이 완료되면 입출력 제어기는 CPU에 인터럽트를 보낸다. 이는 외부 인터럽트이다. 외부 인터럽트는 입출력장치로부터 오는 인터럽트 뿐 아니라 전원 이상이나 기계적인 오류 때문에 발생하는 인터럽트를 포함하므로 하드웨어 인터럽트라고도 부른다. 컴퓨터 시스템에는 다양한 종류의 장치가 있기 때문에 CPU가 어떤 장치에서 받은 인터럽트인지 확인하도록 하기 위해 IRQ라는 고유의 인터럽트 번호를 부여한다.

프로세스의 오류와 관련된 인터럽트는 내부 인터럽트이다. 내부 인터럽트는 예외 상황 인터럽트라고도 부른다. 

사용자가 직접 발생시키는 인터럽트는 시그널이라고 주른다. 작동 중인 프로세스를 끝내기 위해 ctrl + c를 누르는 것이 그 예이다.

<br>



#### :pencil2: 인터럽트 번호

인터럽트 종류에 따른 인터럽트 번호는 다음과 같다.

| 종류          | 인터럽트 번호 | 비고                                      |
| ------------- | ------------- | ----------------------------------------- |
| 내부 인터럽트 | 0 ~ 31        | 20 ~ 31번은 정의되지 않았다.              |
| 외부 인터럽트 | 32 ~ 47       | 주변장치의 수에 따라 유동적으로 할당한다. |
| 시그널        | 128           | 시그널 번호를 따로 기재한다.              |

내부 인터럽트가 발생하면 해당 프로세스가 즉시 종료된다. 이때 운영체제는 어떤 상황에서 오류가 발생했는지 파악하기 위해 프로세스가 종료되기 직전까지 메모리와 레지스터의 상태를 저장하는데 이를 코어 덤프라고 한다. 

IRQ 번호는 각 하드웨어의 장치를 구분하기 위해 붙인 번호로 인터럽트 번호와는 다르다. IRQ 번호와 인터럽트 번호는 일대일로 대응된다.

시그널은 사용자가 만드는 인터럽트이기 떄문에 종류가 매우 다양하다. 그래서 모든 시그널에는 인터럽트 번호 128번을 할당하고 세부 시그널 번호를 따로 명시한다. 

<br>



### 인터럽트 벡터와 인터럽트 핸들러

인터럽트 벡터 : 여러 인터럽트 중 어떤 인터럽트가 발생했는지 파악하기 위해 사용하는 자료 구조로 인터럽트 벡터의 값이 1이면 인터럽트가 발생했다는 의미이다. 

인터럽트 핸들러 : 인터럽트의 처리 방법을 함수 형태로 만들어 놓은 것으로 인터럽트가 발생하면 인터럽트 핸들러를 호출하여 작업을 한다. 

인터럽트 벡터에는 인터럽트 핸들러를 호출할 수 있도록 인터럽트 핸들러가 저장된 메모리의 주소가 포인터 형태로 등록되어 있다.

<br>



시그널의 경우 자신이 만든 인터럽트를 등록할 수도 있다.



#### :pencil2: 인터럽트 핸들러 재등록

인터럽트 핸들러 재등록은 원래의 인터럽트 핸들러를 대신하는 힘수를 등록하는 것을 말한다. 재등록 코드는 다음과 같다.

```c
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>

void handler() { /* 새로운 SIGINT 핸들러 */
    printf("SIGINT-HANA \n");
}
int main(void) {
    signal(SIGINT, handler); /* SIGINT 핸들러 변경 */
    sleep(10);
    return();
}
```

사용자의 handler() 함수를 한 번 사용하고 나면 원래의 인터럽트 핸들러로 돌아간다. 

모든 시그널은 사용자의 핸들러로 대체할 수 있다. 하지만 이 경우 프로세스가 모든 시그널을 무시하고 살아남을 수 있는데 이를 방지하기 위해 9번 시그널만 사용자의 핸들러로 대체할 수 없도록 만들었다. 따라서 kill로 프로세스를 죽여도 죽지 않는 프로세스가 있는 경우 kill -9를 사용하면 된다.

<br>



## 버퍼링

### 버퍼의 역할

버퍼는 속도가 다른 두 장치의 속도 차이를 완화하는 역할을 한다. 느린 장치를 통해 들어오는 데이터를 버퍼에 모아 한꺼번에 이동하면 효율적이다. 대부분의 입출력장치는 버퍼를 이용하여 느린 속도를 보완한다.

커널에서도 버퍼를 사용한다. 커널이 입출력장치로 보내야 할 데이터를 버퍼에 담아 놓으면 입출력 제어기가 커널 버퍼에서 입출력장치로 데이터를 보낸다. 커널이 버퍼를 사용하면 입출력 작업이 완료되기 전에 다른 작업을 할 수 있어 시스템의 성능이 좋아진다. 이는 스풀러를 사용하는 프린터의 경우도 마찬가지이다.

<br>



단일 버퍼보다는 이중 버퍼를 사용하는 것이 버퍼 운용에 유리하다.  단일 버퍼를 사용하면 데이터를 버퍼에 담는 작업과 데이터를 가지고 가는 작업을 동시에 하기 어렵다. 그러나 이중 버퍼를 사용하면 하나는 담는 용도로 쓰고, 하나는 가져가는 용도로 쓸 수 있어 유용하다.

<br>



### 버퍼 운용 시 주의점

시스템의 효율성을 위해 운영체제는 버퍼가 꽉 찼을 때 입출력장치로 데이터를 전송하도록 설계되어 있다. 따라서 데이터가 꽉 차 있지 않으면 일정 시간 후 전송한다. 이 방식은 가끔 문제를 일으킨다. 외부 저장 장치를 사용하는 경우 사용자가 파일을 복사하여도 버퍼가 다 차지 않으면 입출력장치에 자료가 전송되지 않는다. 이 상태에서 저장장치를 제거하면 버퍼 안의 데이터가 저장되지 않는다.

이 특성 때문에 윈도우에서는 하드웨어 안전 제거를 사용할 것을 권고한다. 해당 기능을 사용하면 버퍼가 다 차지 않아도 강제로 버퍼의 내용이 저장장치로 옮겨진다. 이를 플러시라고 한다. 플러시가 일어나면 저장장치의 손상을 방지하기 위해 입출력장치의 전원이 차단된다.

프로그래밍을 할 때도 버퍼의 내용을 강제로 옮기는 명령어를 사용한다. 대표적으로 유닉스의 fflush()가 있다.

모니터도 버퍼를 사용한다. 보통 유닉스 터미널의 한 줄은 80자로 80자를 저장하는 버퍼가 다 차면 모니터에 출력한다. 이때 줄 바꿈 문자를 사용하면 버퍼의 내용을 모니터에 강제로 출력한다.