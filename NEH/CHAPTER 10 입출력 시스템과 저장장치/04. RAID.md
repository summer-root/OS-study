# RAID

## RAID의 개요

RAID는 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템이다. 메모리가 아닌 값싼 디스크를 사용한다. 동일한 규격의 디스크를 여러 개 모아 구성하며, 장애가 발생했을 때 데이터를 복구하는 데 사용된다.

하나의 원본 디스크와 같은 크기의 백업 디스크에 같은 내용을 동시에 저장하고, 하나의 디스크가 고장났을 때 다른 디스크를 사용하여 데이터를 복구하는 원리이다. 이 방식을 미러링이라고 한다. RAID 1은 순수한 미러링을 지원한다.

RAID에는 여러 디스크에 데이터를 동시에 저장하여 데이터의 입출력을 높이는 방식도 있다. 이는 데이터를 여러 조각으로 나누어 보내기 때문에 스트라이핑이라고 한다. RAID 0은 순수한 스트라이핑을 지원한다.

RAID 0은 데이터 전송 속도가 빠르지만 본래 기능인 데이터 복구 기능이 없다. 이러한 문제를 해결하기 위해 미러링과 스트라이핑을 동시에 지원하는 RAID10을 사용하기도 한다.

RAID 0, 1, 10 외에 RAID 2, 3, 4, 5, 6, 50, 60 등도 있다. 이는 오류 교정 코드인 허밍 코드나 오류 검출 코드인 패리티 비트를 이용하여 추가되는 디스크의 양을 줄이는 방식이다. RAID 1의 경우 같은 데이터를 두 군데에 저장하기 때문에 저장하려는 데이터만큼의 디스크 용량을 추가로 갖추어야 하지만, RAID 2, 3, 4, 5는 더 적은 용량으로도 데이터를 복구할 수 있다. 그러나 하드디스크의 가격이 저렴해지면서 복잡한 연산을 필요로 하는 RAID 2, 3, 4, 5는 잘 사용하지 않게 되었다.

<br>



## RAID 0 (스트라이핑)

병렬로 연결된 여러 개의 디스크에 데이터를 동시에 입출력할 수 있도록 구성된다. 같은 규격의 디스크를 병렬로 연결하여 여러 개의 데이터를 여러 디스크에 동시에 저장하거나 가져올 수 있다. 따라서 입출력 속도가 빠르다.

복구 기능이 없기 때문에 장애가 발생하면 데이터를 잃는다. 그렇지만 입출력이 빨라 많이 사용된다.

<br>



## RAID 1 (미러링)

하나의 데이터를 2개의 기스크에 나누어 저장하여 장애 시 백업 시스크로 활용한다. 따라서 같은 크기의 디스크를 최고 2개 이상 필요로 하며, 짝수 개의 디스크로 구성된다. 

단점

- 같은 크기의 디스크가 2개 이상 필요하기 때문에 비용 증가

- 같은 내용을 두 번 저장하기 때문에 속도가 느려질 수 있음

  따라서 데이터 입출력이 없는 시점에 백업이 이루어지도록 조정

<br>



## RAID 2

오류를 검출하는 기능이 없는 디스크에 대해 오류 교정 코드를 따로 관리하고, 오류가 발생하면 이 코드를 이용하여 디스크를 복구한다.

<br>



오류 관련 코드

- 오류 검출 코드 : 오류가 발생했는지 확인할 수 있는 코드로 패리티 비트가 대표적인 예
- 오류 교정 코드 : 오류가 발생했는지 확인하는 동시에 오류를 교정할 수 있는 코드로 허밍 코드가 대표적인 예

<br>



하드디스크의 저장 단위는 블록이다. 그러나 RAID 2에서는 데이터가 비트 단위로 저장된다. 비트를 분리하여 여러 개의 디스크에 나누어 저장한다. 비트 단위로 저장하는 이유는 각 비트의 오류 교정 코드를 구성하여 비트 단위로 복구하기 위해서이다. 비트별로 만들어진 오류 교정 코드는 별도의 기스크에 저장된다.

RAID 2는 n개의 디스크에 대해 오류 교정 코드를 저장하기 위한 n-1개의 추가 디스크를 필요로 한다. RAID 1보다는 작은 저장 공간을 요구하지만 오류 교정 코드 계산에 많은 시간을 소비하기 때문에 잘 사용하지 않는다.

<br>



## RAID 3

RAID 3과 RAID 4에서는 오류 검출 코드인 패리티 비트를 사용하여 데이터를 복구한다. 메모리의 경우 패리티 비트로 오류를 찾을 수는 있지만 교정하지는 못한다. 하지만 RAID의 경우 패리티 비트로 오류를 복구할 수 있다.

패리티 비트에는 짝수 패리티 비트와 홀수 패리티 비트가 있다. 짝수 패리티 비트는 1의 총수를 짝수로 만드는 것이고, 홀수 패리티 비트는 1의 총수를 홀수로 만드는 것이다. 

4개의 디스크가 있고 별도의 디스크 1개에 짝수 패리티 비트를 보관했다고 가정했을 때 하나의 디스크에 장애가 생겨 복구해야 한다면 짝수 패리티 비트와 나머지 디스크의 1의 개수를 근거로 장애가 발생한 디스크의 값을 알 수 있다.

RAID 3은 RAID 2와 같이 데이터를 여러 개의 디스크에 나누어 저장한다. 이때 차이점은 RAID 2는 비트 단위로 데이터를 나누어 저장하지만, RAID 3은 섹터 단위로 데이터를 나누어 저장한다.

일반적으로 디스크는 섹터 단위로 읽기 때문에 섹터에 대한 오류 여부를 알 수 있다. 따라서 패리티 비트를 여러 섹터끼리 묶어 구성하면 오류가 없는 섹터를 이용하여 오류가 있는 섹터의 데이터를 복원할 수 있는데 이를 N-way 패리티 비트 방식이라고 부른다.

RAID3의 경우 추가되는 디스크의 양은 적지만 N-way 패리티 비트를 구성하는 데 필요한 계산량이 많다.

<br>



## RAID 4

RAID 4는 RAID 3과 같은 방식이지만 처리하는 데이터가 블록 단위로 되어 있다. 

데이터를 모든 디스크의 섹터에 나누어 저장하는 방식으로 패리티 비트를 구성하면 데이터를 읽거나 쓸 때 패리티 비트를 구성하기 위해 모든 디스크가 동시에 동작해야 한다. 

RAID 4에서는 데이터를 하나의 디스크에 블록 단위로 저장하고 패리티 비트를 블록과 연결하여 구성한다.

모든 패리티 비트가 하나의 디스크에 저장되기 때문에 입출력이 일어날 때마다 패리티 비트 디스크에 데이터가 저장되어 병목 현상이 발생한다. 또한 패리티 비트가 저장된 디스크와 다른 디스크에서 동시에 장애가 발생할 경우 복구가 불가능하다. 

RAID 4도 추가되는 디스크의 양은 적으나 계산량이 많다.

<br>



## RAID 5

RAID 4와 같은 방법을 사용하지만 병목 현상을 해결한 것이다. RAID 5에서는 패리티 비트를 여러 디스크에 분산하여 보관함으로써 병목 현상을 완화한다. 또한 패리티 비트가 있는 디스크가 고장 나면 복구가 어려워지는 문제도 해결한다.

RAID 5에서는 패리티 비트를 해당 데이터가 없는 디스크에 보관한다. 따라서 한 디스크에 장애가 발생하면 다른 디스크에 있는 패리티 비트를 이용하여 데이터를 복구할 수 있다.

<br>



## RAID 6

RAID 5와 같은 방식이지만 패리티 비트가 2개이다. 

RAID 5의 경우 디스크 2개에 동시에 장애가 발생하면 복구가 불가능하다. 디스크 2개에 동시에 장애가 발생하면 패리티 비트가 사라지기 때문이다. RAID는 이를 해결하기 위해 패리티 비트를 2개로 구성하여 디스크 2개의 장애를 복구할 수 있다.

패리티 비트를 2개씩 운영하기 때문에 계산량이 많다는 것과 4개의 디스크 당 2개의 추가 디스크가 필요하다는 단점이 있다.

<br>



## RAID 10

빠른 입출력이 장점인 RAID 0과 복구 기능을 가진 RAID 1을 결합한 형태이다. RAID 10과 유사한 형태로 RAID 0+1이 있으나 복구의 효율성 문제로 RAID 10이 더 많이 사용된다.

- RAID 0+1 : 4개의 디스크를 2개씩 묶어 RAID 0으로 구성하고 RAID 0으로 묶인 디스크를 RAID 1로 다시 묶는다. 장애 발생 시 복구를 위해 모든 디스크를 중단해야 한다.
- RAID 10 : 4개의 디스크를 2개씩 묶어 RAID 1로 구성하고 RAID 1로 묶인 디스크를 RAID 0으로 다시 묶는다. 장애 발생 시 일부 디스크만 중단하여 복구할 수 있다.

<br>



RAID 0+1과 RAID 10 둘 다 병렬로 데이터를 처리하여 입출력 속도를 높일 수 있으며 장애 발생 시 미러링된 디스크로 복구가 가능하다.

<br>



## RAID 50과 RAID 60

RAID 10과 마찬가지로 같은 RAID를 0으로 묶어 성능을 높이는 방식이다. 

RAID 50, RAID 60의 장단점은 RAID 5, 6의 장단점과 같다. RAID 50과 RAID 60은 RAID 10에 비해 추가되는 디스크의 수가 적지만 입출력 시 계산량이 증가한다

